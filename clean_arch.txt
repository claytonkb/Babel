NOTE: IF YOU GET error: expected ')' before '=' token IN OPERATOR #define
THIS IS DUE TO YOU NEED TO #include "operator.h"

OLD SP LIBRARY: C:\babel\2014May3\Babel\demo 

BUGS at EOF

TODO

base64e working

Implement inte-substitutions:
void bstruct_substitute(bvm_cache *this_bvm, mword *target_bs, mword *find_bs, mword *sub_bs){ // bstruct_substitute#

    - binary heaps ... implement now?
        http://www.cs.ucf.edu/~dmarino/ucf/cop3502/sampleprogs/heap.c
        http://courses.csail.mit.edu/6.006/fall10/handouts/recitation10-8.pdf
        http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/Sorting/heapSort.htm

    - Byte-Pair Encoding
        This may be a good candidate if it can be implemented with reliably 
            fast compression time.
        http://www.csse.monash.edu.au/cluster/RJK/Compress/problem.html
        Paper: "Byte pair encoding: a text compression scheme that accelerates pattern matching"

    - String-matching

        string_ascii_char_match (fast scan for a character)
        string_ascii_char_match_all (fast-scan for all chars, e.g. "/", " ", "\n", etc.)
        string_ascii_str_match (first match only; returns offset)
        string_ascii_str_match_all (returns list of offsets)
        array_match      --> general-purpose matching, i.e. UTF8 strings; also rooted sub-graphs
        array_match_all

        http://igm.univ-mlv.fr/~lecroq/string/index.html

        Current favorite: Boyer-Moore Horspool
            Very fast + simple + good worst-case

    - Vector/tensor processing

        Why vectors/tensors:
            Very fast in CPU/GPU
            Eliminate pointer-manipulation - O(1) lookup for every access
            Uses:
                Multi-media (images, audio, video, etc.)
                Multi-precision arithmetic/averaging
                Histograms/probabilities/entropies
            Non-uses:
                Ragged/irregular-shaped data
                Dynamically-resizable data (unless chunked/blocked)
                Very small data objects in isolation, such as characters or bits

        Implement after support for large pages + GC-max-alloc-page-size
        https://gcc.gnu.org/onlinedocs/gcc-4.2.4/gcc/X86-Built_002din-Functions.html
        https://www.youtube.com/watch?v=6Q8_kYbTqhY&list=PLLcTTp6EQ_egylIerYEjCBbEVhnPzSdXP
        https://software.intel.com/sites/landingpage/IntrinsicsGuide/#

        Sub-language
            Vector-processing programs run in separate interp-loop
            Programs are themselves packed into vectors
            Overall architecture?

        Key interface between vector and normal modes: scatter and gather

            rows --> matrix
            [a a a] [b b b] [c c c] [d d d] --> [a a a b b b c c c d d d]
            matrix --> rows
            [a a a b b b c c c d d d] --> [a a a] [b b b] [c c c] [d d d]

            matrix(interleaved) --> rows
            [a b c d a b c d a b c d] --> [a a a] [b b b] [c c c] [d d d]
            rows --> matrix(interleaved) 
            [a a a] [b b b] [c c c] [d d d] --> [a b c d a b c d a b c d]

            rows(interleaved) --> matrix
            [a b c d] [a b c d] [a b c d] --> [a a a b b b c c c d d d]
            matrix --> rows(interleaved) 
            [a b c d] [a b c d] [a b c d] --> [a a a b b b c c c d d d]

            Transpose orientation as interleaving:

            1  2  3      1  4  7  10
            4  5  6  ==> 2  5  8  11
            7  8  9      3  6  9  12
            10 11 12 

            4,3   col-size,row-size
            [a a a b b b c c c d d d]    [1 2 3 4 5 6 7 8 9 10 11 12]
                                          ^ ^ ^
            3,4
            [a a a a b b b b c c c c]

            3,4 T
            [a b c d a b c d a b c d]

            4,3 T
            [a b c a b c a b c a b c]    [1 2 3 4 5 6 7 8 9 10 11 12]
                                          ^     ^     ^     ^
            2,4,3
            [a a a b b b c c c d d d e e e f f f g g g h h h]
                multi-dim transpose?

    - Variadic tensors (pyramids)

        Vector/tensor data type cannot be resized (without a new allocation)
        Variadics allow "growable/shrinkable" vector/tensors
        For example, instead of {256 newval}, we use {256 newptr} and then 
            set each element of this array to point to a 1 element val-array,
            as each element comes available.
        Variadics are either packed or sparse; a packed-variadic is expected
            to be filled "left-to-right"; a sparse-variadic can be arbitrarily
            indexed
        Variadics can be nested according to any regular dimensional geometry
            but the leaves are always a value-array, that is, a standard 
            vector/tensor

    - SCRATCH BPDL2
        
        Copy from bpdl.c, then:

            - Implement ns_list
            - Implement lambdas (bstruct lambda)
            - Think about slambda (sexpr lambda)

    - Dev feature: dump all interp stats into a val-array (allows automated
        perf-tracking scripts).

    - Interpreter perf boost

        - Stack_depth/dia caching (remove quadratic slowdown with stack-depth)
        - General stack-caching
        - Stack-operand salvaging
        - Dynamic allocation list / dynamic free (use find_ptr)
        - Memory-page-size management / increment_alloc re-work
        - Scratchpad allocation (see mem-alloc stats)
        - Selective caching? (valid-bit per field)
        - instrument-based profiling of where we're spending most of our time
            (e.g. tptr_detag()); re-factor, #define and inline to streamline
        - code-list to array for inner loops
        - -O3
        - Try to eliminate memset from newlfi
        - Set mem_alloc bactrack point per opcode in case of MC_GC_OP_RESTART

    - Memory-page-size management

        Allocating very large single-page sizes increases the likelihood that
        malloc() will return NULL.

        A linked-list of smaller memory pages would ease this bottleneck. 
        However, the copy-collect GC always converts the entire BVM into a
        single chunk requiring a memory page at least as large as all IN-USE
        memory at the time GC occurs.

        Implement a tagged data-structure to create a kind of "virtual value-
        array" that is stored as a linked list of smaller value arrays? Does
        this interact with tensors?

        It may also be useful to track largest allocated object.

        - GC perf enhancement: increment_alloc should not release
          already-allocated banks; instead, should just maintain a list of banks
          and allocation should cycle through the available banks.

    - Stack-operand salvaging

        Implement a mem_salvage() function which is called by the dstack_pop()
        function - note that current implementation directly calls stack_pop()
        so will need to wrap it and call mem_salvage() from there.

        The mem_salvage() function works by leveraging the architecture of the
        alloc pages to check the last allocated pointer in the alloc page
        against whatever pointer(s) are passed to it. If a match is found, it
        rolls the alloc pointer back to salvage that allocation.

        Order matters a lot, so this function may benefit from maintaining a
        small buffer of most-recent failed salvage calls. After each
        successful salvage, the contents of the buffer are retried in case
        these were merely blocked by bad ordering.

            pseudo-code:
                try to roll-back curr_ptr
                if fail ->
                    add to end of recent_buf or overwrite last entry if full
                    increment end_ptr if < recent_buf_size
                    sort recent_buf
                    set curr_ptr = top of recent_buf
                a: try again to roll-back curr_ptr
                    if fail, go to done
                    if succeed, go to next entry of recent_buf
                    goto a
                done:
                    if entries were removed in (a), re-sort recent_buf if not empty
                    fix end_ptr

    - PERF: Selective caching
        - Inefficient to update/flush entire cache in situations where we know
            the specific dirty/invalid items

    - PERF: add stack_depth and stack_dia tracker fields to the bvm_cache

    - PERF: scratchpad-stack
        Circular, fixed-size scratchpad area where operand-pointers are stored 
        until operated upon. Each entry is marked valid/invalid; when the 
        stack pointer rolls around to a valid entry (scratchpad is full), it 
        evicts that entry. This eliminates mem_alloc overhead without any perf
        penalty to other kinds of code. E.g. a tight loop can run much faster:

            (iter %d << " " <<) 100000 times

        When an operator consumes operands out of the scratchpad area, the 
        pointer moves back. This prevents the pointer from continually evicting
        in tight loops like the one above.

    - PERF: scratchpad-value, scratchpad-pointer, scratchpad-tag and scratchpad-cons
        Circular, fixed-size scratchpads similar to above for the stack. These
        are circular scratchpads that are marked valid/invalid and an entry is
        only evicted when the pointer "rolls around" to it.
        The four kinds of scratchpads that are maintained are for:
            - values; leaf array of size 1, this is basically for numerics
            - pointers; inte array of size 1; these are commonly generated by 
                a variety of operators
            - conses; inte array of size 2; these are the most common of all
            - tags; a byproduct of many hash operators
        NOTE: scratchpad entries are ONLY generated by operators and are either
            invalidated or evicted when cosumed by subsequent operators... 
            this must be done to ensure coherency

    - Mem alloc profiling stats:

        20263       2 (individual vals, ptrs)
        26898       3 (cons-box)
        9350        4
        2963        5
        1388        6
        1006        7
        1474        8
        -----
        63342

        0.319
        0.425
        0.148
        0.047
        0.022
        0.016
        0.023

        2 -> 32%
        3 -> 43%
        4 -> 15%
        5 -> 5%

        These four alloc-sizes account for about 95% of all allocs size 8 or
        less. (Profiling stats based on loading std.sp)

        Raw stats from running smoke.sp:

            PROFILE_ALLOC_SIZE_2 0000da3f   55871   33%
            PROFILE_ALLOC_SIZE_3 0001170a   71434   42%
            PROFILE_ALLOC_SIZE_4 00005d1f   23839   14%
            PROFILE_ALLOC_SIZE_5 00001ebd   7869    5%
            PROFILE_ALLOC_SIZE_6 00000f32   3890
            PROFILE_ALLOC_SIZE_7 00000935   2357
            PROFILE_ALLOC_SIZE_8 00000f8f   3983
                                            169243

        These are small samples but stats look stable over various workloads.

    - Re-think /babel/ref/syntax in light of LUTs

        bstruct ==> LUT ==> bstruct  <-- this is a function that can return another function

    - How Babel lambdas work:

        <lambda_table> <sexpr> lambda --> <sexpr>

        [lambda foo (x y z) {{z y {itod <<} 2 times} x times}]

        [lambda bar x (x x)]

        (1 2 3) foo --> {{3 2 {itod <<} 2 times} 1 times}
        (1 2 3) bar --> ((1 2 3) (1 2 3))

        bstruct_substitute(val) is used to substitute each occurrence of each
        given variable name in <sexpr> with the corresponding bstruct in the
        list provided as an argument to the lambda expression. (NOT EFFICIENT)

        Once the sexpr has been substituted, it is interpolated into the
        surrounding sexpr list.

    - [\ ...]
        
        Lambda syntax (another alternative)

        [\ (x y) [wordcat "The " x "can " y "."] ] ("car" "drive")
        [\ (x y) [wordcat "The " x "can " y "."] ] ("dog" "run")
        
        [sym foo [wordcat "The " x "can " y "."] ]
        [sym bar [\ (x y) foo ] ]

        bar ("ball" "bounce")

    - bpdl2 (bpdl rewrite) notes:

        Phase 1: Lambda & Macro Build

            During this phase, user lambdas and user macros are identified and
            built. The build process for user lambdas & macros proceeds
            through all subsequent phases.

        Phase 2: Lambda-application

            Lambdas are applied to the sexpr-tree to yield a new sexpr-tree

        Phase 3: BPDL transform

            BPDL terms are transformed to appropriate constants, labels are
            substituted and macros are run

        Phase 4: Flattening

            BPDL tree is flattened to a single leaf array and then loaded
            and the result is returned

        --------

        Is there a way to do bpdl solely as a series of sexpr-rewrites? This
        would be the most conceptually "pure" approach...

        Starting with [bs ] as outer list (most difficult case):

            1 Build bs_tree
            2 Set first entry as sexpr_root
            3 Locate user lambdas
            4 For each user lambda:
                4a Traverse sexpr and make all identifiers into tptr's
                4b find_tags(nil); traverse and substitute from bs_tree
                4c Apply any built-in lambdas, as appropriate
                4d Repeat 4a-c until no substitutions
            5 For each user macro:
                5a Traverse sexpr and make all identifiers into tptr's
                5b find_tags(nil); traverse and substitute from bs_tree
                5c Apply any built-in lambdas, as appropriate
                5d Repeat 5a-c until no substitutions
            6 Starting with sexpr_root:
                6a Traverse sexpr and make all identifiers into tptr's
                6b find_tags(nil); traverse and substitute from bs_tree
                6c Apply any built-in or user lambdas, as appropriate
                6d Repeat 6a-c until no substitutions
            6 Starting with sexpr_root:
                6a Flatten list; apply macros, as appropriate
                6b Recurse (DFS) to children
            7 Load flattened list and return

        ------

        Non-[bs ] outer list:



    - Importing/exporting symbols

        Currently, can import a map into the root of the symbol-table. Once
        namespaces, pwd and [ref ] lists are implemented, this will be done in 
        a local directory instead of to root.

        How does this connect to [bs ] lists and constructing a bstruct with
        an added export table?

        What if you had a list of [bs ] lists?

        ( [bs s01 [ptr s04 s06 ] s04 [val 0x1 ] s06 [val 0x2 ] ]
          [bs s01 [ptr s04 s06 ] s04 [val 0x1 ] s06 [val 0x2 ] ] )

        What would it mean for these [bs ] lists to export a symbol-table??

    - Before tearing into bpdl2.c, implement interpolating macros in bpdl.c
        Needed for prototyping purposes

    - Also, implement find_ptr, find_tag, tag_substitute, and
      sym_ref_substitute (preparation for lambdas)

        find_tag, tag_substitute DONE

    - Named nest
        clear and save current stack to a symbol
        named unnest: restore stack from symbol

        What to call?

           stack_save stack_restore 

    - Thoughts on object model

        BVM is the fundamental object-model in Babel
        Solve: soft_root vs. code_ptr construction from BPDL description

        Use [bs foo$ <blah blah>] to place foo into the export-table

        --        
        Feature: Reset code_ptr on exit (flag + reset_point)
            User-accessible/configurable

        When BVM is exited, its execution point is "reset" for next invocation

        This permits BVM to be accessed somewhat like an object, with the
        difference that BVM itself is responsible for method dispatch. This is
        not as bad as it sounds since the BVM may do nothing more than eval
        the user argument:

        foo widget_BVM <
        (frobnicate) foo babel --> foo uses eval to invoke the frobnicate
            method

        MANAGING NAMESPACES

            We need ability clone/share namespaces in a sensible way

            By default, the babel operator imports/shares pwd namespace in
                which it is launched? Use babels operator to explicitly import
                symbol-tables:

                ( (sym-table-list) args ) babels

        What about std??
            Maybe make std an interpreter built-in, like opcode_table and
            macro_table? Make it automatically visible in every soft_root...

    - Because Babel uses bpdl, need to add bpdl2.c back
        Leave current bpdl in place for Babel core functionality
        Fix symbol table issues, clean up code.

    - lambdas (redux)

        Works basically the same as macros, but takes ONE argument from current
        list (will require to add tracking).

        [lambda triplify (x) x x x]
        (1 2 (3) triplify) --> (1 2 3 3 3)
        (1 2 ((3) triplify)) --> (1 2 (3 3 3))

        [lambda twister (x y z) z y x]
        (1 2 (3 4 5) twister) --> (1 2 5 4 3)

        [macro rev rev]
        (1 2 [rev 3 4 5] 6 7) --> (1 2 5 4 3 6 7)
        (1 2 ([rev 3 4 5]) 6 7) --> (1 2 5 4 3 6 7)

        [lambda lsrev (x) [rev x]]
        (1 2 (3 4 5) lsrev 6 7) --> (1 2 5 4 3 6 7)

    - Interpolating vs. non-interpolating macros
        Syntax (original idea)
            (1 2 [pair  (3 4) (5 6)] 7 8) --> (1 2 ((3 5) (4 6)) 7 8) --> non-interpolating
            (1 2 [pair* (3 4) (5 6)] 7 8) --> (1 2  (3 5) (4 6)  7 8) --> interpolating

        Implementation
            inline_bpdl() returns list with format (bstruct interpolating)

        Why not just ALWAYS interpolate, and if that's not what the user
        wants, they just surround it with parens?

            (1 2  [pair (3 4) (5 6)]  7 8) --> (1 2  (3 5) (4 6)  7 8) --> interpolating
            (1 2 ([pair (3 4) (5 6)]) 7 8) --> (1 2 ((3 5) (4 6)) 7 8) --> "non-interpolating"

        What about value-arrays?

            foo [1 2 3] <
            bar [4 5 6] <

            [ 7 8 9 [arcat foo foo] ]

    - Let-code-list

        [let (x y z) <code>]

        Creates fixed-pointers to x y and z in <code>; inserts top stack
        elements into these locations

    - Implement unescape_non_quote() in bpdl.c - Removes back-slashes

    - De-cruft --> "temp" in variable names
        grep returns at least 84 instances

    - Resource logic (linear logic)
        https://en.wikipedia.org/wiki/Linear_logic#The_resource_interpretation

        Important for controlling any kind of resource-allocation, including
        memory and time.

    - mkbvm2

    - Meanings of operators

        x >= y
        "x must be greater-than-or-equal to y"
        "it is true that x is greater-than-or-equal to y"
        "is it true that x is greater-than-or-equal to y?"
        "there is an x or y such that x is greater-than-or-equal to y"
        "find an x given y that satisfies x is greater-than-or-equal to y"
        "give all x such that x is greater-than-or-equal to y"
        "given x and y, the greater-than-or-equal relation makes the
            statement true"

    - Implementing num2str_fd/str2num_fd using strtod() and ???

    - Working on lib_bpdl() ... call from 1 dev not returning anything on stack

    - Add BABEL_INTERP_INITD flag to bvm_cache to track interp initialization

    - Add floating-point operators

        Use GMP; case-closed

        https://gmplib.org/manual/GMP-Basics.html#GMP-Basics

        Hard part: Installing GMP and ensuring portability

            checking for suitable m4... configure: error: No usable m4 in $PATH or /usr/5bin (see config.log for reasons).
            gmp-6.1.0>

        Need GNU m4 macro processor. Try reinstalling Cygwin? Or just switch
            to Linux dev env?

            >>>DEPRECATED<<<
            >Required for cross-platform support
            >AND SO THE HEADACHES BEGIN...
            >    sprintf() only supports lobotomized double-to-string conversion on
            >    MSWin because of msvcrt.dll limitations
            >
            >Manual conversion:
            >    http://www.exploringbinary.com/quick-and-dirty-floating-point-to-decimal-conversion/
            >    (also interesing): http://www.exploringbinary.com/converting-floating-point-numbers-to-binary-strings-in-c/
            >
            >Don't use dtoa() by David M. Gay
            >
            >-- Multiplication
            >
            >    Peasant mult. (lattice-mult, wallace-tree, etc.)
            >
            >    sel=1 (init)
            >    row -> 0 0 1 1 2 2
            >    col -> 0 1 1 2 2 3
            >    sel -> 1 0 1 0 1 0
            >
            >    sel=0 (init)
            >    row -> 0 1 1 2 2 3
            >    col -> 0 0 1 1 2 2
            >    sel -> 0 1 0 1 0 1
            >
            >    Number of diagonals:
            >    length of side + 
            >      length of bottom
            >
            >    diagonals(3,2) = 5
            >
            >    --> Still need to work out the "minimal diagonal" of whole
            >    multiplications required to perform each layer of the
            >    multiplication in order to avoid having to multiply out an entire
            >    grid.
            >
            >-- Inverse algorithm

    - Bug causing seg-fault on smoke.sp with mem=1<<20 but not 1<<24 or 1<<12

    - Compile-time eval + prefix-order eval

        [+ 2 3] --> 5
           ^^^
           |||
           collected into a list; list is give'd into null-BVM

        Different than Lisp because this must execute at compile-time.

        [rev (1 2 3)] --> (3 2 1)

        [rev (1 [+ 2 3] 4)] --> (4 5 1)

        [ls2lf (1 [+ 2 3] 4)] --> [4 5 1]

        [each (1 2 3) {itod}] --> '3'
            NOTE: Null-BVM only returns its TOS, so rest of stack is
            discarded; to prevent this, collect the items into a list...

        [! { (1 2 3) {itod} each collect ! }]
           ^
           |
           recurse here, return value becomes the thing we give to the
           null-BVM; IOW, don't pass the elements of the list to null-BVM
           until every sub-list has been evaluated, in case there are
           nested/buried prefix-lists

        -->How Babel does constant-folding?

        Also, how about infix-notation (while we're at it)?

            [| 2 + 3 ] --> 2 3 +

    - Cross-platform basic window GUI reference:
        https://github.com/ziacko/TinyWindow

    - return, return-on-exit

--> finish implementing return operator in _babel() (check BVM_RETURN_TOS_ON_EXIT)

        last operator causes exit if it is in the root code-list
        exit operator exits (breaks from interp_core)
        return operator sets the return-tos-on-exit BVM flag, then exits
            what about stepping?

        flags->RETURN_VALUE_BLOCKED --> parent BVM can set this to force
            return-value to always be nil

        flags->RETURN_TOS_ON_EXIT --> The return operator sets this flag
            during exit

        flags->BVM_CODE_LIST_EMPTY --> This flag is set when exiting due
            due reaching end of code_list

        return-value is handled in _babel() ... differentiate between exit
            due to stepping and final exit

    - sel/selr change-proposal

        sel ==> choose
        "a" "b" "c" 3 1 choose  --> "b"
        "From the top 3 items on the stack, choose the 1th from TOS and remove
        the others"

        selr ==> if/ifte
        <bool> <term> if
        <bool> <then-term> <else-term> ifte

    - mem stress-testing

        foo { { "{ {'.' <<} 100 times }" sexpr bpdli eval } 10 times 'done/n' << } mkbvm ! <
        foo 3500 stepnbvm !

        ...

        babel> clear
        mem_preemptive_op_restart() in src/mem.c line 165
        mem_swap_banks() in src/mem.c line 281
        mem_reset_bank() in src/mem.c line 302
        clean_babel>

        It appears that the GC becomes unstable after stressing and goes caput
        on a preemptive_op_restart after mem_reset_bank

        -------

        mword *load_bbl = (void*)mem_alloc(this_bvm, BYTE_SIZE(BBL_SIZE)); // BBL_SIZE is sfield/4
        --> segfaults with memsize = 1<<11

    - sexpr block-quoting

        [bq 
            END_BLOCK
            foo bar blah blah
        END_BLOCK]

    - Underscore syntax-sugar:
        
        3 _ +   -->  3 swap +
        (_)     -->  1 take !
        [_]     -->  1 takeptr !

    - [quote ] (quotes an s-expression)

    - get/set access operators

        Need to modify _trav to handle exact type of traversal
        Enumerate traversal types...
            - ???
            - ???

    - dev operator for I/O redirection (command-line logging)

    - Lambdas

        Instead of macros, what about inline bpdli (with eval)? Null BVM or just run
        on current BVM for PoC...

        OR bpdl in babel...

        bpdl() is essentially a "partial lambda". It can substitute multiple
        symbols at once (multi-variate lambda), and it can substitute symbols
        from several levels simultaneously.

        However, bpdl() lacks the ability to define lambda functions and to
        apply them. We should re-design bpdl() from scratch to perform all
        three simultaneously:

            - symbol substitution (naming)
            - lambda definition
            - lambda application

        Lambda-definition and application require a syntax that bpdl can recognize.

            [(x) (x x x)] --> lambda definition

            [(x) (x x x)] --> lambda application

            [(x y) (y x)] --> "lambda swap"

            (1 2 3) (4 5 6) [(x y) (y x)] --> (4 5 6) (1 2 3)

            1 2 3 + [(a b c x) ({(a b c) {x 2 times} !})] --> (1 2 3) {+ 2 times} !
                                              ^^^^^
                                              When/where is this looked up??

        Each time we come across a lambda, we get its arguments from the last
        N entries of the current list (keep a current_list pointer to do
        this). We then create a hash-table from these arguments and recurse
        to bpdl()

        Along with lambda-definition/application, we also need preprocessor
        symbols. This is a separate symbol-table that is discarded after bpdl() is
        finished, meaning, preprocessor symbols cannot be accessed afterwards.

            [# triplify [(x) (x x x)]]

            ...

            {3 triplify} --> 3 [(x) (x x x)] --> 3 3 3

        Note: The following will not work:

            "{3 triplify}" sexpr bpdl !

        This is because the symbol >triplify< has already been discarded by
        the time we reach runtime.

            [# sq [(x) ({x x *})]]

    - bpdl re-write

        [bpdl [sym0 ...] [sym1 ...] [# preproc0 ...] [# preproc1 ...] [sym2 ...] ... ]

            base_offset=0
            v
            [ptr [val 1] [val 2] [val 3]]
                 ^       ^       ^
                 |       |       base_offset=0x20
                 |       base_offset=0x18
                 base_offset=0x10


            [ptr [val 1] [val 2] [val 3]]
            fffffff4 00
            00000014 04
            0000001c 08
            00000024 0c
            00000004 10
            00000001 14
            00000004 18
            00000002 1c
            00000004 20
            00000003 24


            -----------
            fffffff4 00 <<<< base_offset = 0

            00000014 04

            0000001c 08

            00000024 0c
            -----------
            00000004 10 <<<< base_offset = 0x10
            00000001 14 >>>> bs_ptr = 0x14

            00000004 18 <<<< base_offset = 0x18
            00000002 1c >>>> bs_ptr = 0x1c

            00000004 20 <<<< base_offset = 0x20
            00000003 24 >>>> bs_ptr = 0x24
            -----------


            foo [ptr [val 1] [ptr [2] [3]]]
            -----------
            fffffff8 00

            00000010 04

            00000018 08
            -----------
            00000004 0c
            00000001 10
            -----------
            fffffff8 14
            00000024 18
            0000002c 1c
            -----------
            00000004 20
            00000002 24
            -----------
            00000004 28
            00000003 2c


        Move toward sparse.pl-style encoding

        Create list-of-lists
            [ptr type (entries) flattened base_offset]

        If type==val
            Each entry is either a value or a substitution-tag
            Unresolved-label tags not allowed

        If type==ptr
            Each entry is a relative-offset (value) or a susbtitution-tag or
                an unresolved-label tag

        If type==list
            Each entry is a relative-offset (value) or a susbtitution-tag or
                an unresolved-label tag

        If type==code
            Each entry is a relative-offset (value) or a susbtitution-tag or
                an unresolved-label tag

        The sum of the lengths of the lists is found and a leaf-array (final_array) of this size is allocated
        In order, each list has a relative base-offset assigned to it
        For ptr, list and code, all pointer-tags and substitution-tags are substituted with the correct base-offset
        For each ptr, list and code:
            each pointer offset is incremented by the relative base-offset
            The entries are packed into final_array           

    - New introspection idea:

        [bs ...] --> essentially replicates sparse.pl

        should be a super-set of bpdli (i.e. code-lists, lists, etc.)

        <bs expr> --> sexpr --> remember name of first clause
            foreach clause
            use first token as key into hash-table
            second token is inserted as raw-sexpr

            hash-table is now constructed

            starting from name of first clause:
            encode_bs
                switch (ptr, val, tptr, tag, code)
                encode_ptr:                    
                encode_val:
                encode_tptr:
                ...

    ------------------

        Unload first, then convert to string...
        Allows full "round-trip"
        This will be the $ operator?

        Need to have direct-pointer-syntax and label-syntax working properly first...

            00 00000058
            04 fffffff8     s0004
            08 00000010
            0c 00000018
            10 00000004     s0010
            14 00000001
            18 fffffff8     s0018
            1c 00000024
            20 0000002c
            24 00000004     s0024
            28 00000002
            2c fffffff8     s002c
            30 00000038
            34 00000040
            38 00000004     s0038
            3c 00000003
            40 00000000     s0040
            44 3023f4e7
            48 8c2f644d
            4c 71cf647b
            50 e974b23a
            54 fffffffc
            58 00000040

            (1 2 3) bs2str -->

            [bs
              s0 [ptr s1 s2]
              s1 [val 0x1]
              s2 [ptr s3 s4]
              s3 [val 0x2]
              s4 [ptr s5 s6]
              s5 [val 0x3]
              s6 nil ]
               ^
               calculate width based on unloaded size; divide by 4 and decrement

        Worry about wrap-around? First impulse is to leave that for some other text-processing function

    - implement recursion operators

        linrec : [P] [T] [R1] [R2] -> ... 
        Executes P. If that yields true, executes T. Else executes R1, recurses, executes R2. 

        tailrec : [P] [T] [R1] -> ... 
        Executes P. If that yields true, executes T. Else executes R1, recurses. 

        binrec : [B] [T] [R1] [R2] -> ... 
        Executes P. If that yields true, executes T. Else uses R1 to produce two intermediates, recurses on both, then executes R2 to combines their results. 

        genrec : [B] [T] [R1] [R2] -> ... 
        Executes B, if that yields true executes T. Else executes R1 and then [[B] [T] [R1] [R2] genrec] R2. 

    - canonical bstruct encoding
        bstruct with prefix-free property
        encoding:

            1^x 00 y[0:x] z[0:y]
            z is payload
            y is signed payload bit-size (binary encoding)
            x is size-of-y (unary encoding)

            y > 0 --> z is a value-array, bit-size = y
            y < 0 --> z is a pointer-array, bit-size = -1*y
            y = 0 --> z is a tag (see following encoding):

            1 00 0 1^x 00 y[0:x] z[0:y]
            z is payload
            y is unsigned payload bit-size (binary encoding)
            x is size-of-y (unary encoding)

        Double-zeroes maintains alignment on 32/64/128-bit machines

    - Implement some string-scanning operators (ala memchr)
        Need these in order to efficiently process strings
        Also, need to start thinking about building regex primitives
            + * ? | () [] [^]
        Basic idea:
            Implement scanning primitives using C stdlib calls
            Implement any/all/negation/nesting using alt-seq constructs

        Regular expression quick reference:
        .	Wildcard: any character
        *	Repeat: zero or more occurrences of previous character or class
        ^	Line position: beginning of line
        $	Line position: end of line
        [class]	Character class: any one character in set
        [^class]	Inverse class: any one character not in set
        [x-z]	Range: any characters within the specified range
        \x	Escape: literal use of metacharacter x
        \<xyz	Word position: beginning of word
        xyz\>	Word position: end of word

    - Add an each8 iterator

    - journal operator should leave file-descriptors open; close open file-
        descriptors only at end-of-code_list

    - Add sys resource tracking into bvm_cache
        - E.g. open file descriptors
        - Need this due to garbage-collection... getting seg-faults when
            GC'ing across file I/O operations. Not 100% sure this will fix it
            but this is best guess so far.

    - Re-organize tracing:
        - Add a global TRACING_ENABLE (switch off all tracing at a single
          point)
        - Build in support for logging;
            - mem_dump_core should go to a log file
            - should be able to target tracing to a log file
            - add global_tick_count to logging operation so can compare 
                STDOUT tracing with tracing logs

    - Add INTERP_BOOT_IN_PROGRESS flag to detect that _op_restart is
      catastrophic and any other conditions like that; fail gracefully

    - Remove the LOWWATER and HIGHWATER flags... confusing

    - Arbitrary-precision addition:
        If two arrays are same size, allocate result +1
        If one array is larger than the other, allocate to the largest
        Add mword by mword, and track any carries
        If src arrays were same size and final mword of result is 0,
            truncate the result
        See cadd_cod
        Multiplication can use 16-bit lo/hi and peasant algorithm
        Exponentiation by squaring
        Division/log are complicated in binary, but trivial in 2-adic
            After we get add/mult/exp working, look at switching to 2-adic

    - Instead of using lusym in bpdl.c, pass the sym-table as an argument

    - dynamic versus static macros

        static macro: [foo ...]
        dynamic macro: (args) {code} maceval
            Acts like nest operator but when it is finished, it edits itself
            out of the code-stream. Suppose our maceval returns 0x123:

                ... 0x456 (args) {code} maceval 0x789 ...

            After maceval:

                ... 0x456 0x123 0x789 ...

            Whenever this code-list is subsequently executed, it will no longer
            invoke maceval but will, instead, simply place 0x123 on the stack.

            The interpreter will have to add a pointer that tracks back the
            past few steps of the code-list:

                ... 0x456 (args) {code} maceval 0x789 ...
                    ^                   ^       ^trackforward pt
                    |                   |
                    trackback pt        maceval operator

    - Time - we need to start thinking about it...
        DWORD WINAPI GetTickCount(void); // Windows
        clock_gettime(CLOCK_REALTIME, &spec); // Linux

    - Add a su (super-user) flag and operator
        su operator sets the flag. Opcodes which can affect interpreter can only
        execute when flag is set (one-instr window).

    - get array8 operators online
        -- cut8/slice8/paste8/move8

    - An idea for large-static allocations that go around GC:

        We need to implement this feature in order to eliminate MC_USE_MALLOC

        MC_DYNAMIC_ALLOC flag

            There will be a dyn operator that will set the MC_DYNAMIC_ALLOC
            flag for one instruction cycle - any instruction occurring in that cycle
            (including an operand-push) will have its memory allocated via mem_sys_alloc.

            Ex.
            "very_large_file.bin" dyn >>>   --> The slurp is not allocated from mem->primary
            1000000 dyn newlf               --> 4MiB memory allocation with dynamic memory

            In order for this to work properly, we need to make a result_mem_alloc
            wrapper around mem_alloc that is always and only used when allocating 
            an operand result. This is the function that will check MC_DYNAMIC_ALLOC.

            Unlike the MC_USE_MALLOC debug flag, this flag has built-in security by
            being zero'd out on EVERY instruction cycle. In addition, the 
            dyn opcode itself, like any opcode, can be locked, preventing an
            untrusted BVM from utilizing dynamic memory at all.

        dyn uses mem_sys_alloc() instead of mem_alloc, so the user is responible
            to delete it, or it will hang on for good (GC does not clean it up). 
            The memory used by dynamic memory is decremented from from the reservoir, 
            just like normal allocation. The reservoir is only incremented upon 
            delete.

            Ex.
            1000000 dyn newlf delete --> this memory block is now freed

        When GC occurs, the BVM is searched for each of these pointers (using 
            bounds-checks) and a special tag (e.g. /babel/tag/dynamic_ptr) is substituted,
            indicating that there was a dynamic pointer in this location, and its offset in
            the dynamic_mem list. This occurs during unload. During load, the opposite
            occurs, the BVM is searched for the /babel/tag/dynamic_ptr tag.

        Note on bounds-check: We can have situations where we have a GC_overflow condition
            and the dynamic_mem list is non-empty; thus, the bounds check is
            just a filter, the pointer is not confirmed to be dynamic memory 
            until we have looked it up in the dynamic_mem list

        delete removes the pointer from the list and takes no other actions. Note
            that it's safe to delete the same pointer any number of times because
            Babel will search the dynamic_mem list and only call free() if the
            pointer is present in that list

        destroy removes the pointer from the list (if it exists) and searches
            the BVM for any occurences of the pointer and substitutes a pointer to
            nil in its place

        -----

        We can use this as a generalized solution to the global interpreter constants
            issue (such as opcode_table) by simply using new to allocate the memory
            after the dynamic_mem list has been initialized.

        -----

        pre-UNLOAD:
        search the BVM for pointers outside the primary->base bounds; if a pointer
            is out-of-bounds, then it is a dynamic_mem pointer; find the index 
            of this pointer in the dynamic_mem list and then substitute a
            /babel/tag/dynamic_ptr tptr pointing to a value that contains the index
            for the dynamic memory in the dynamic_mem list;

        post-LOAD:
        create a tptr_span() function that acts like bs2ar/span, but returns a list
            containing pointers *ONLY* to tptrs with a tag matching the tag given
            as argument

        foreach pointer in this list, look up the corresponding index and restore
            the original from the dynamic_mem list

    - pack/unpack

    NOTE: Just use valmap/keymap + ls2lf to implement pack
    Use {{arlen} over !} to create unpack indices
    If pack must go in a certain order, user must provide the key-list

        Analogous to the Perl functions... but different

        Three varieties: pack, pack8 and pack1 - mword, byte and bit resolutions

        Pack creates two outputs:
            - a leaf-array containing the packed data
            - a hash-table containing named offsets into the packed data

        ( "foo" 123
          "bar" [456 789] 
          "baz" bop) pack --> [123 456 789] <hash_table containing "foo":0, "bar":1, "baz":3>

        Unpack does the opposite - it takes a hash-table with offsets, and uses
            this to construct a list corresponding to the original; 
                A   pack unpack --> A
                B,C unpack pack --> B,C

    - Nested-paging and automagic-filenames... meditate on it...

    - Implement a stack-cache

        Pre-requisite: leaf packed-records

        How work?

        Should treat each stack entry as a boiler-plate; the only thing read/written
        on most cycles should be the data pointer and the alloc_type

        if the alloc_type indicates that an operand was generated by an opcode
        (not pushed on the stack), then we can simply invalidate its entry in the
        stack-cache without the need to write out to memory; it's an intermediate
        value; this does not conflict with dup;

    - SP file re-org:
        root.sp - Babel root BVM; compiled in with the executable for security;
                    will eventually perform some code verification/validation
                    and handle any kind of exception that can only be handled
                    at the interpreter level
        cli.sp  - The main CLI; handles argv, envp, debug-stepping, etc.
        std.sp  - Babel minimal-STD library; contains moderate set of commonly-
                    used convenience functions; not a full-blown STD suite;
                    automatically included by CLI but can be switch-overridden
        rc.sp   - User-specific utility code; can be quickly loaded with rc ! from CLI
        opcode_table.sp - The opcodes; this will also be compiled in with the 
                    executable for security (arbitrarily changing the meaning of
                    opcodes is a huge security hole).

    - enhance bpdl with primary, secondary, tertiary and quaternary sym_table args
        primary:    local_root (equiv to [let ] ?)
        secondary:  soft_root
        tertiary:   temp_bs_hash
        quaternary: link_hash? (compare with expansion-tags)

    - Add a /null directory to soft_root and enforce *nix-like /dev/null behavior

    - libbabel...
        libbabel(char *babel_string) --> returns mword *TOS
        libbabel_arg(char *babel_string, mword *arg) --> returns mword *TOS

    - clean up load/unload/sexpr/bpdl with corner-cases (use bs2str2 to streamline this)

    - auto-eval
        "/babel/tag/auto_eval" --> This tag in code-stream triggers auto-eval
        The code to be eval'd is looked up in sym_table
        Then passed to the eval() function
        Not quite a macro, because still run-time only
        Better in certain cases than normal eval because:
            - does not require separate eval-operator cycle... avoids the !
            - always goes through sym_table (instead of stack)

    - Create a "semicolon" pseudo-operator ...

        > 2 2 + ;
        [val 0x4 ]
        > --> equiv to:
        > 2 2 + dup bs2str << "\n" <<
        [val 0x4 ]

        --> Think about how to do pseudo-operators more generally... is it worth it?
            Create a null-BVM? Pre-load operators during init? On-demand?

    - would also be nice to have built-in escaping for multi-line commands ...

        > 2 \
        2 + ;
        4>

    - macro thoughts

        { {"Hello, " "world\n" .+ <<} 1000 times }  --> automagically becomes:
        {"Hello, world\n" <<} 1000 times

            HOW??

                Can we rethink macros as a special-case of constant-folding? I.e.
                    a macro is a "nested constant-folding"? The advantage of this
                    is that macros are no longer a "separate" kind of thing...
                    they are just evals that occur at compile-time
                Closely-related: disposable (compile-time) symbol-table versus 
                    final (run-time) symbol-table. This is actually related to
                    folding, as well. If a symbol can be "folded away", then it
                    does not need to be in the RT sym_table. Otherwise, we need
                    to keep it. Thus, the same function can be used as both a
                    macro (invoked during compile-time) and as a run-time 
                    function, without the need to redefine it separately.

                - only code-lists get constant-folded
                - but have to explore entire code-tree because we might have
                    a list of code-lists

                ({+} {*} {-} {/}) {<- 2 3 -> !} ...

                - exploration of the code-tree is depth-first
                - cfolding of a code-list occurs as a series of 'folding attempts'
                    the whole list may be collapsed down in a single attempt
                    or (more likely) it may be foldable code interspersed with 
                    non-foldable code

                - there is some fixed set of operators that are foldable;
                    all other operators break us out of a folding attempt
                    - eval operator is special case
                        - it is "normally non-foldable"
                        - however, if the entire code-list referred to by the
                            eval operator is foldable, then the eval operator
                            itself becomes foldable

                            {2 3 +} ! --> This is a foldable-eval and can be reduced to 5

                    - what about loops?

            { >> {"a" .+} 100 times } --> NON-FOLDABLE

                1. The "a" is put on the folding-attempt stack
                2. The .+ operator is encountered, but there is only one item on the stack
                    - This code-list is, therefore, non-foldable
                NOTE: Each time we recurse down into the tree, we must create a blank stack,
                        otherwise, we could not detect the above condition
                NOTE: This also illustrates that cfolding cannot think for you - although
                        it may not be obvious, the following is a much superior way to do
                        the same task:

            { >> "a" {"a" .+} 99 times .+ } 
                 ^^^^^^^^^^^^^^^^^^^^^ --> FOLDABLE

        GET TAKE/GIVE WORKING AND THEN TRY TO MERGE WITH INTERACTIVE MODE
            Also, get the round-trip syntax working

        Imagine we define a macro 'strrev':

            [macro strrev 
                str2ar ar2ls 
                rev 
                ls2ar ar2lf]

        Later:

            { ... "foo" strrev ... }

        Such macros always process just one arg?

            [str2ar "foo"] --> { ... "foo" str2ar ... }

        We are dancing on the edge of constant-folding issues...

            { ... 3489 17 + ... }
                  ^^^^^^^^^
                  this should not be left to run-time

        Is there a way to define "parsing" in terms of a Babel runtime?

        That is, can we make "all-at-once" parsing act like interactive Babel?

        If we can, then macros become trivial and constant-folding becomes a matter
        of examining the constants on the stack at each step.

            parse-tree --> stack/code/sym_table --> BVM

        "flow-control" macros

            [if {my_cond}
                {"hello" <<} 
            --else
                {"world" <<}]

            [cond
            {cond_a}
                {eval_a}
            {cond_b}
                {eval_b}
            {cond_c}
                {eval_c}
                {eval_default}]

        Macro example:

            -1 take {itoa <<} each

            [over {itoa <<}]   --> equivalent to above

            [macro over
                <- {-1 take} ->
                   {each}
                3 take append]

    - Hoare logic:
        Natural fit to Babel; create library support for doing Hoare logic in
        Babel;

        Also, fits well with randomized testing

             |-------------------| <-- stack isometry
            A B {+} ... B {-} --> A
                   |---| <-- stack isometry

        By creating templates of this form for each operator, we can construct
        a robust randomized testing framework

    - set operator needs to recognize when its operands are tptrs...
        - enhance oinfo and get_operands() to handle this case...

            > x [1 2 3] <
            > x [1] 7 set
            > x bs2str <<
            [val 0x1 0x2 0x3 ]  >

            > x > [1] 7 set
            > x bs2str <<
            [val 0x1 0x7 0x3 ]  >


    Get in-line tptrs working in operand.c

    get/set re-architect...
        trie_insert() is screwing up the _cp of the hash when it is
        given a tptr instead of a leaf-hash... FIXME


    Get local_root working and init'd just like soft_root    

    Root: Slurpy-Babel execution
        - build BVM hash-table, except code_ptr
        - slurp in Babel file
        - compile it
        - insert into code_ptr
        - execute with babel operator

    Commandline use cases:
        - Compile plain-text --> byte-code
            babel -c foo.bbl
            outputs foo.bbc unless input filename ends in something other than
                .bbl ... in that case, it outputs filename.bbc
        - Run byte-code (resume paused/saved BVM)
            babel -b filename
            babel foo.bbc
                ^^^ shorthand works if filename ends in .bbc
        - Run plain-text
            babel foo.bbl
            babel -p foo.bbc
                ^^^ longhand if filename ends in .bbc ... this is bad style though
        - Interactive mode
            babel

            Use the run meta-operator to run a bbc or bbl file

        - Scripting mode (STDIN/STDOUT pass along stack)
            babel -s foo.bbl | babel -s bar.bbl
        - Debug mode (interactive compile)
            babel -d foo.bbl

            Use the debug meta-operator to enter debug mode from run mode

            ci --> code-injection
            si --> stack-injection
            li --> local symbol injection
            gi --> global symbol injection

            run, step, prompt (enter and go to prompt)

        - Command-line mode
            babel -e "2 2 + itoa <<"
        - Command-line stack-init mode
            babel -t sum.bbl 1 2 3 4 5
            Each arg following the script-name must be a Babel-constant
                Bare-words are auto-quoted
        - Symbolic debug mode
            Requires defining of /babel/tag/sym_babel

    - Add a spit/slurp for hex plaintext to facilitate bbc files without binary mode
        spith/slurph

    - null bvm for internal code-injection tasks

    DATA-STRUCT SHOOTOUT:
        - Array
            - Use th or pbp to access elements
        - List
            - Use ith or pbp to access elements
        - Map
            - Use luha/insha to access elements
        - Map-of_Maps -> Namespace to access elements
            - Use URI syntax to access elements
        - Object/Struct
            - Use ref to access elements
                - ref can do th, pbp, ith, luha, URI + other
                - Uses tags to determine how to do a particular lookup/insert

    SYNTAX SHOOTOUT:
        - PBP + Refs + Sigils + Basic-types + Local/Global + Generic operators...

    - Local root
        --> This is the default sense of a bare identifier (unrooted reference)
    - References, [ref 'foo' 'bar' 'whatever' 0 17 'bin.rec']
    - URI-reference syntax: /foo/bar/whatever[0](17)/bin.rec
        /foo/bar/whatever[0](17)/bin.rec     PASSIVE
        /foo/bar/whatever[0](17)/bin.rec<    READ
        /foo/bar/whatever[0](17)/bin.rec>    WRITE
        /foo/bar/whatever[0](17)/bin.rec!    EXECUTE

        -> unrooted reference = local
        -> rooted reference   = global
        -> direct-pointer syntax?

        ref -> local reference (read) ... alias for lref

        refg -> global reference (read)
        refl -> local reference  (read)
        
        refgw -> global reference (write)
        reflw -> local reference  (write)
        
        refgx -> global reference (execute)
        reflx -> local reference  (execute)
        
        refgp -> global reference (passive)
        reflp -> local reference  (passive)

    - http://blogs.microsoft.co.il/sasha/2016/01/05/windows-process-memory-usage-demystified/
    - How to build a compiler:
        - http://compilers.iecc.com/crenshaw/
        - http://home.iae.nl/users/mhx/crenshaw/tiny.html
        - http://www.cs.indiana.edu/~dyb/pubs/nano-jfp.pdf
    - https://lists.freebsd.org/pipermail/freebsd-current/2010-August/019310.html
    - http://www.daemonology.net/blog/2015-12-06-magic-getopt.html 
    - bpdl
        - label-like first element -> needs special-case handling to become macro-expander
    - Symbolic expansion
    - [sym ...] (creates entry in sym-table
    - Handle tptrs in code-stream (do operand rework first?)
    - Nested text-block syntax
    - Sort, setting, grep, macex, auto-zap-control (operands), pearson
    - Command-line, STDIN capture, babel operator argument
    - Babel exec/fork
    - std.bbl loads for interactive mode unless disabled with -m switch (bare Metal)
    - inline_bpdl is working for list_list... now for code_list
        - slurp in opcodes.bbl for processing built-ins?
        - or just make it a .c file like construct.sp.c?
    - insha appears to be broken; anything using it is probably broken; why aren't
        we using only trie_insert()??
    - get arcmp working (for sparse_sym compares)
    - implement inline_bpdl
    - sel/selr --> how should sel's "accumulate"? i.e. multiple sels (think binary tree)
    - last/cond
        - cond enhancement- Final element of cond-list is "default", no need for {1}{...}
    - BVM_SYM + babel + GC + memory resizing
    - debugger/REPL
    - conjure (save/restore)
    - Interpreter reset
    - Local root
    - References, [ref 'foo' 'bar' 'whatever' 0 17 'bin.rec']
    - URI-reference syntax: /foo/bar/whatever[0](17)/bin.rec
        /foo/bar/whatever[0](17)/bin.rec     PASSIVE
        /foo/bar/whatever[0](17)/bin.rec<    READ
        /foo/bar/whatever[0](17)/bin.rec>    WRITE
        /foo/bar/whatever[0](17)/bin.rec!    EXECUTE
    - [sym ...] (creates entry in sym-table
    - Handle tptrs in code-stream (do operand rework first?)
        - Debugger symbols + line-number/file info, etc.
    - CLI/stdin/stdout/nesting/etc.
    - Macro expansion
        - [X] --> creates an expansion-tag
    - retry-sel operator + macros -> alt/seq
    - pass/fail -> accept/reject
        - laziness (p6-style lazy-lists?)
            - use a special tag to cause the interpreter to invoke
                a "generator" when the tag is encountered...
        - p6-style-junctions
        - accept on first true (or accept)
        - reject on first false (or reject)
            of course, save & restore state as appropriate
    - Soft-exception (code on stack) versus hard-exception
    - Flags
        - Operators can set flags to indicate warning/error conditions
        - Configurable behavior:
            - Exit on error   (appears as exception to parent BVM)
            - Exit on warning (appears as exception to parent BVM)
            - Interp vs. BVM exit
                - catastrophic vs. fatal
    - stack cleanup; divide stack into:
        - simple push/pop stack
        - doubly-linked stack (complete with flip/twist/etc.)
        - try to eliminate rstack.*
    - Bstruct-Tagging
        - "frontier"... a tag past which the tagger-typer is disabled
        - RWX tags
        - Container tags ("only type X can go here")
    - Operand-tagging
        - "All the arguments you need are on the stack, in some order"
            - Operands are not recognized based on *order*
        - Allow stack-entries to have an associated name, bypassing
        the need to insert/delete from a symbol table
        - Do we really need TWO tags per stack entry?
        - Initially, we can start with adding support for "named operator
            arguments" - {a' <<} "code_block" stag 5 "num_rep" stag times
        - Can be implemented through macros?
    - [: 40] anonymous state macro
        range:
    - [^ 40] same as 40^ but works with anything; preserving macro
    - iteration
    - regularizing operands?
    - rmw-each and reg. each
    - dedicated stacks, not just rstack
    - list-of-list as matrix... list/tree-shaping
    - records, packed records, etc. array shaping
        - offsets hash table
        - record + array -> array-as-stack?
    - pure babel pointer
        - pbp in ref
        - hash of pbp's into unloaded data-structure... convert between
            "packed" offsets and "unpacked" pbp's
            - utilize "pbp_leaf" lookup to find offsets after unloading
        A leaf-array of indices
        Can point "into" a leaf-array; also points as a range:
        e.g.
            [1 2 3 4 5] [0] >                   -- puts 1 on TOS
            [1 2 3 4 5] [1 3] >                 -- puts [val 2 3 4] on TOS
            [1 2 3 4 5] [val 0] 7 <                 -- [val 7 2 3 4 5]
            [1 2 3 4 5] [val 2 4] [val 7 8 9] <     -- [val 1 2 7 8 9]

            [> 0 3]     --> macro that creates auto-read-pure-pointer
            [< 0 3]     --> macro that creates auto-write-pure-pointer

            [1 2 3 4 5] [1 3] >   -- puts [2 3 4] on TOS

                can also work in list mode:            

            (1 2 (3 4) 5) (2 0) >   -- puts [ptr 3] on TOS

            get, set ===>    > and < resp.
            get8, set8 ===>    $> and $< resp.
                --> take a bstruct & pure pointer as input
                --> can select a single element or "range" within a leaf
            getr, setr
                --> take a bstruct & pure pointer as input
                --> can select a range of either leaf or interior array
get/set ---> steps ---> stepper ---> debugger

    - mem_increment_alloc
        - this appears to be working:
            - we really need to swap banks before calling GC
            - but this means both banks are in use when the allocation is
                incremented
            - since increment allocates all-new memory, might as well just
                allocate both at the same time...
        - need to implement mem_decrement_alloc !!!
    - pearson
        Add Marsaglia XOR32
            After hashing through the pearson table, do the following:
                mword hash[4] = pearson16(key) 
                mword final_hash[4]
                final_hash[2] ^= _marsaglia_fuzz(hash[3])
                final_hash[1] ^= _marsaglia_fuzz(hash[2])
                final_hash[0] ^= _marsaglia_fuzz(hash[1])
                final_hash[3] ^= _marsaglia_fuzz(hash[0])
        This method preserves progressive hashing and it reverses the
        left-to-right flow used by pearson16(). And it's fast.

        CORRECTION: This must be done on EACH iteration of the hash

        http://xorshift.di.unimi.it/

    - Sort, setting, grep, macex, auto-zap-control (operands), 
        - auto-copy of operands...
        - folding non-zap?
                17 
                ({a ==^} "a"
                 {b ==^} "b"
                 {c ==^} "c") 
                cond
        - implement let() and local_root before deciding what to do here...
    - clean up operand-info fields in operator definitions
    - BS traversal with array
        full array-m traversal
    - Multi-load (load multiple .bbc files)
    - Command-line, STDIN capture, babel operator argument
    - Babel exec/fork
    - File/directory operators
    - Crypto
        - AES http://www.literatecode.com/aes256 ? libtomcrypt ? use both and compare?
        - SHA-2 512 (sphlib? libtomcrypt?)
        - PK crypt... RSA? ECC? DH?
    - Bzip2 (zlib?)
    - TCC compile
        - libtcc link
    - tranpose operator
    - manual eval of control structures
    - opcode map rework
    - Slice enhancement- Negative numbers index from end of array
    - code-injection
        - babel_jit?
    - stack-effect
        Allow declaration of stack-effect...
        ("val" "val") ("val") { + } evalf
    - Padding an array-m
    - bstruct diff
    - bstruct find/replace (del operator)
    - Mid-array References, mixed arrays, opaque data-structures
    - linking, inline C, operator extensions
        - auto-linking (use libtcc parser to extract linkable tokens)
        - add syntax for list of inline-C-extended-operators
        - (inline (foo bar baz))
            ...
          foo: <C-code here>
          bar: <C-code here>
            etc.
    - visible whitespace -----
    - floating point
        This could be a good place to apply inline-extended-operators
    - user-accesible flags to allow flagging/logging errors without throwing
        exceptions
    - revisit utf-8 support (html.sp shows that utf-8 at least partly works)
        https://bitbucket.org/knight666/utf8rewind
    - pnums
    - stack: mark, copy and insert
        mark ---> marks a point in the stack
        copy ---> copies from the marked point in the stack
        insert ---> moves from the marked point in the stack

        up and down are treated differently... if you mark then move
        down, then copy/insert will move down as well. vice-versa for
        if you mark and then move up.

        Example:

             1 2 3 mark <- <- copy copy copy
             +----------------+
             |                |
             3                |
             2                |
             1                |
    mark ==> 3                |
             2                |
             1                |
            ---               ^ "BOS"
             | <==TOS         |
             |                |
             +----------------+

             1 2 3 mark <- <- copy copy copy
             +----------------+
             |                |
             |                |
            ---               ^ "BOS"
             3 <==TOS         |
             2                |
             1                |
             3                |
             2                |
             1                |
             +----------------+

        There is just one mark. It moves in the stack whenever the "mark" 
        operator is executed but there is no "unmark" operator. At startup, 
        the mark is made at TOS before any operands are pushed, so the 
        copy/insert operators work as if you had made a mark at the 
        beginning of code.
    - unload PERF rework
    - SUPERSIZED ALLOCs:
        - Set a longjmp in the interp_core loop for memory restarts
        - If an oversized alloc request comes through, we set GC_PENDING and
            we add the oversized alloc request to the list of alloc pages.
            If additional oversized alloc requests come through during the
            same opcode, we will keep an "oversized_alloc" field that will
            accumulate all such requests. Each new allocation will allocate
            the *accumulated* memory requests. Unfortunately, this could
            lead to exponential memory consumption, so we need to watch out
            for conditions where this could occur.
        - When GC runs, it de-allocs all but the current page and one extra
            page. If that extra page is not of the same size as the current
            page, it gets de-alloc'd too.
        - OPEN ISSUE: We may need to set a flag to indicate that unwind is
            past the point of no-return... if we've already modified the
            bstruct, then unwinding can have unpredictable results. We
            either have to manually track the modifications for unwinding,
            or we have to just have to take a cat_except whenever we get
            an unexpected large allocation past the unwind point of no return.
    - SDL link
    - lua-style generation of babel programs
    - General PERF review
    - general recursion operator
        - key is n-ary
        - takes three functions: one for leaf, one for inte and one for tptr
        - can use _fn_recurse to start with... but should be enhanced to allow
            the user to determine the current "key"
    - tagged-pointer hooks in interp_core
        User can install new hooks that are auto-detected and trigger some
        action, just like the built-in hooks. These will be detected under
        the is_tptr() section of the interp_core loop. This is a sort of low-
        level "macro". Would be nice to make this to work with inline-C.


-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
----------------------------OLD BABEL ARCH-----------------------------------
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------

NOTE: Some of this *is* still valid

Babel Architecture

Note that this file contains a lot of deprecated/obsolete information 
which is not marked as such. I'm just using it as a running reference
during the development process.


Bug List
----------------

GC bugs are back. It appears that GC is failing after second call - 
is this due to memory corruption or improper initialization?

Try: instrument and trace
Try: completely free and realloc page in mc_swap_bank
Try: calculate usage properly

- There's a bug somewhere in bs2gv. Try running : perl babel demo/bstruct.sp demo/sexpr.sp.bbl
    Was this the tptr bug?
- GC bug with root BVM
- Bug when returning from babel op in root BVM (maybe related to GC bug)
- unload bug persists
- There's a problem with the UTF-8 encoding/Unicode/array-8... something's 
    not right (I think)
    Check out the micro-utf-8 library: http://puszcza.gnu.org.ua/software/microutf8/
    Also, check out ICU http://site.icu-project.org/

Tasks
----------------

Re-rooting with bvm_sym:
    - Run hello.sp compiled as bvm_sym as root bvm
        % bin/babel.exe -b demo/hello.sp
        % bin/babel.exe -e demo/hello.sp.bbc > demo/hello.sp.bbc.c
        Add .h
    Now, how to compile this in place of construct.sp.c without changing make.pl?
    Switch between make.pl and sym_make.pl
        don't forget to change the #include "construct.sp.h" stmt in babel.h

    BVM_SYM appears to work... ran hello.sp.bbc thru run2.sp
    Next step: rewrite root.sp in BPDL syntax and build .bbc for it
        Consider checking in and forking?

    Need to get self-reference working:
        (foo [ptr foo])
        - Stitch-list
        - Copy repo
        - Patch-up option

    DO:
        encode_section -> encode -> encode_ptr

        change encode and encode_* to take an argument denoting the "symbol"
            if symbol is nil
                normal behavior
            else
                do the list stitching

Think about local_root ... should it work with let? a new operator (local?)
    Raises new save/restore/caching problems
Test out garbage-collector with new changes to update_cache/flush_cache

Final stretch:
    - Implement an sexpr-parsing operator due to perf issues with native Babel parser
        sexpr -> equivalent to balanced_parse; macros can process this output
        benc  -> equivalent to encode
        bpdl  -> {sexpr benc}

        May12: nest_sexpr/capture_sexpr are broken... need to get the
                sexpr_stack working correctly

    - BVM_SYM
        - BVM_SYM root construct
    - GC bug extermination
    - Multi-load (load multiple .bbc files)
    - File/directory operators
    - Crypto
        - AES http://www.literatecode.com/aes256 ? libtomcrypt ? use both and compare?
        - SHA-2 512 (sphlib? libtomcrypt?)
        - PK crypt... RSA? ECC? DH?
    - Bzip2 (zlib?)

Laziness Redux
--------------

We need a concept of laziness. Laziness ultimately means "only do as much 
computation as necessary to generate the next bit of information to let the
rest of the overall computation move forward." We can restrict the idea of
laziness to just lists, as Perl6 does, but this seems overly-restrictive.

What we really want is something similar to each but where the code is 
invoked on some irregular condition determined by the larger computation. The
problem is that, with each, we can say to the user: "Don't muck with your code
or data while the each is running, unless you really, really know what you're
doing... because you're going to get garbage." But you can't say this for
general laziness... "Don't change your stuff". The whole point of the program
is to change stuff.

So, we can use a similar trick as we used with alt/seq - we take a "snapshot"
of the lazy code and store this off somewhere. Only this special copy is run
during the irregular invocations. The user can continue to modify the originals
as desired, without altering the behavior of the lazy operator.

The canonical example of laziness is a cartesian product. 

    ('a' 'b' 'c') ('1' '2' '3') cart { give . } each  --> 'a1' 'b1' 'c1' 'a2' 'b2' 'c2' 'a3' 'b3' 'c3'

What if the lists we are cart'ing are gigabytes in size? Wouldn't it be nice
to be able to only take the cart as needed? For example, map can be defined as
cart diag:

    ('a' 'b' 'c') ('1' '2' '3') cart diag { give . } each  --> 'a1' 'b2' 'c3'

So, suppose we wanted to map two 1GB lists... this should not require 1GB^2 
space. The problem, here is that somehow diag needs to tell cart "I only need
the first element of the first row, the second element of the second row..."
Is there ANY existing language that does this??

pre-BPDL
--------

foo:
    bar: {"Yo!" <<}
    baz: [val 17]
bop: 
    (1 1 2 3 
    5 8)

([dir 'foo' 
    ([sec 'bar' {"Yo!" <<}]
    [ sec 'baz' [val 17]])]

[sec 'bop' (1 1 2 3 5 8)])

dir --> create a new hash-table
sec --> create an entry in the current hash-table

cond enhancement
----------------

Final element of cond-list is "default", no need for {1}{...}



Slice enhancement
-----------------

Negative numbers index from end of array
    Perl6 rejected this!

S-expression redux
------------------

    [X Y]

X is the s-expression type.
Y are the elements of the s-expression list 

Babel interprets X in the following order:
    - Predefined types (code, list, val, etc.) incl. built-in macros
    - Macro name (must be present in the "macros" list)
    - Global symbol definition ([X Y] <===> [sym X Y])

Empty s-expressions:

[] -> nil

[X]

In this case, Babel constructs a macro-expansion tag. A macro-expansion
tag is "/babel/tag/macex" pointing to a tag that is the hash of X.

Macros redux
-------------

Macro-list:

    macros: (foo bar baz)

    These sections will now be invoked as macros if they occur

    This is header-ish and bureacratic... see about adding a sigil to 
    mark off macros from other kinds of forms

Built-in Macros:

    [] -> nil

    [mac foo X]
        Creates a macro named "foo" that does X

    [! A {B}] --> A is pushed on stack, B is invoked on it *at macro-time*.
        This is how Babel does "constant-folding"

    [| (A + B) * C] --> infix order

    [|| { . "foo" {. 'b' 'a' 'r'} } ] --> lisp order evaluation macro
        Hrm....

    [map   ] --> create a new hash-table
      [sec ] --> create an entry in the current hash-table


    [^ X] --> preserving macro?.. after X is evaluated, whatever is on 
                TOS is cp'd

        catk: [^ .]  --> cats TOS . TOS-1, then cp of that

        Not sure this is all the way thought-through...

    [// ] regex macro?

    [@ ] interpolating macro:

        (1 2 [@ (3 4)]) === (1 2 3 4)

    [_ ] flattening macro

    [- -]           block-comment
    [blah- -blah]   heredoc-style block-comment

    [blah# #blah] heredoc-style quote

    [> ] read-reference macro
        [> "/foo/bar/0/7"] --> [ref "foo" "bar" 0 7]

    [< ] write-reference macro
        relative-absolute, etc.

    [mx X] --> macro-expansion of X
        [X] --> same

    [: X] --> equiv to [tag X]

    [% "foo"] --> hash macro, equiv. to [! "foo" %]

    pbp's, packed-records, etc.

    control-flow macros

Recursion
------------------------

this?:

    {decision} 
        {option-A} 
        {option-B} 
    binrec

or?:

    ({cond1}{option1}
     {cond2}{option2}
     {cond3}{option3})
    recurse

etc.


Stack: Flip and Flop
------------------------

Stack rework:

Change stack to doubly-linked list (car, cdr, prev). Connect stack
bottoms to form circular-doubly-linked list. Call this the 
"Bottom of Stack" or BOS.

Operators: flip, rot, twist, up, down, get, put, depth, dia
    flip    swap dstack/ustack
    rot     swap TOS/BOS
    twist   reverse just the dstack, leave ustack unchanged
    up      move to prev of TOS
    down    move to next of TOS    
    get     grabs N items off dstack and saves them on rstack
    put     puts items from rstack back onto dstack
    bottom  next of TOS until TOS = BOS (put everything on ustack)
    top     prev of TOS until TOS = BOS (put everything on dstack)
    depth   size of dstack
    dia     size ("diameter") of entire stack
    clear   clears the stack
    nest    save current stack, create fresh stack
    give    push all elements of list on TOS onto the stack
    take    collect N items off the stack

            a b c d <- <-
             +----------------+
             |                |
             a                |
             b                |
            ---               ^ "BOS"
             c <==TOS         |
             d                |
             |                |
             +----------------+


            a b c d <- <- rot
             +----------------+
             |                |
             c                |
             d                |
            ---               ^ "BOS"
             a <==TOS         |
             b                |
             |                |
             +----------------+

            a b c d <- <- flip
             +----------------+
             |                |
             d                |
             c                |
            ---               ^ "BOS"
             b <==TOS         |
             a                |
             |                |
             +----------------+

            a b c d <- <- flip rot (same as a b c d <- <- rot flip)
             +----------------+
             |                |
             b                |
             a                |
            ---               ^ "BOS"
             d <==TOS         |
             c                |
             |                |
             +----------------+

            a b c d <- <- twist
             +----------------+
             |                |
             a                |
             b                |
            ---               ^ "BOS"
             d <==TOS         |
             c                |
             |                |
             +----------------+


Opcode map
----------------

Opcode encodings:

    Bits        Meaning
    ----------------------------
    0           Auto-zap
    15:1        Built-in opcodes
    31:16       Extended opcodes



    opcode[15:4] (hex)      Operator Types
    --------------------------------------

    000-03f                 Arithmetic 
    040-07f                 Shift 
    080-0bf                 Logic 
    0c0-0ff                 Comparison 

    1xx                     Stack

    200-23f                 Bstruct
    240-27f                 Array
    280-2bf                 List
    2c0-2ff                 Hash

    300-33f                 String
    340-37f                 Alloc
    380-3bf                 I/O
    3c0-3ff                 Pearson

    400-47f                 Eval
    480-4ff                 BVM

    500-53f                 C-compatibility
    500-53f                 Read-write
    500-53f                 Reference
    500-53f                 Tags

    6xx                     Util/Dev

    7xx
    8xx
    9xx
    axx
    bxx
    cxx
    dxx
    exx
    fxx                     Future expansion prefixes


    Arithmetic 000-03f
        cuadd           002
        cuadd^          003
        cusub           004
        cusub^          005
        cumul           006
        cumul^          007
        cudiv           008
        cudiv^          009
        curem           00a
        curem^          00b
        ciadd           00c
        ciadd^          00d
        cisub           00e
        cisub^          00f
        cimul           010
        cimul^          011
        cidiv           012
        cidiv^          013
        ciabs           014
        ciabs^          015
        cirem           016
        cirem^          017
        add_assign      018
        add_assign^     019
        sub_assign      01a
        sub_assign^     01b
    Shift
        cushl          
        cushl          
        cushr          
        cushr          
        curol          
        curol          
        cashr          
        cashr          
        curor          
        curor          
    Logic
        logicF0        
        logicF0        
        logicF1        
        logicF1        
        logicF2        
        logicF2        
        logicF3        
        logicF3        
        logicF4        
        logicF4        
        logicF5        
        logicF5        
        logicF6        
        logicF6        
        logicF7        
        logicF7        
        logicF8        
        logicF8        
        logicF9        
        logicF9        
        logicFa        
        logicFa        
        logicFb        
        logicFb        
        logicFc        
        logicFc        
        logicFd        
        logicFd        
        logicFe        
        logicFe        
        logicFf        
        logicFf        
        and            
        and            
        or             
        or             
        not            
        not            
        cnot           
        cnot           
    Comparison
        cne            
        ceq            
        cult           
        cule           
        cugt           
        cuge           
        cilt           
        cile           
        cigt           
        cige           
    Stack
        dup            
        zap            
        swap           
        sel            
        up             
        down           
        give           
        take           
        depth          
        nest           
        clear          
        flip
    Bstruct
        sfield         
        mu             
        nva            
        npt            
        nlf            
        nin            
        span           
        load           
        unload         
        cp             
        bs2gv          
        bs2str         
        isinte         
        isleaf         
        istptr         
        newin          
        newlf          
        newtptr        
    Array
        th             
        move           
        move8          
        paste          
        paste8         
        arlen          
        arlen8         
        cat            
        cat8           
        slice          
        slice8         
        arcmp          
        cut            
        trunc          
        ar2ls          
        ar2str         
        shuf           
        sortlf         
    List
        car            
        cdr            
        cons           
        uncons         
        pop            
        push           
        shift          
        unshift        
        ith            
        len            
        ls2lf          
        bons           
        split          
        append         
        ins            
        trav           
        walk           
        rev            
    Hash
        hash           
        hash8          
        phash          
        phash8         
        newha          
        rmha           
        insha          
        inskha         
        entsha         
        luha           
        exha           
        keysha         
    Eval
        eval           
        times          
        while          
        loop           
        each           
        eachar         
        goto           
        if             
        ifte           
        cond           
        seq            
        alt            
        pass           
        fail           
        let            
        die            
        last           
        next           
        iter           
        conjure        
    BVM
        msize          
        exit
        bvmrstack      
        bvmsym         
        hibernate      
        bvm_step       
        self           
        bvmstack       
        bvmcode        
        bvmustack      
        fnord          
        babel          
    String
        str2ar         
        cu2dec         
        cu2hex         
        ci2dec         
        hex2cu         
        dec2ci         
        nl             
        ord            
    I/O
        slurp8         
        spit8          
        journal8       
        stdout8        
        stdinln        
        slurp          
        spit           
        stdout         
    Util
        sleep          
        rand           
        boilerplate    
        endian         
        exec           
        dev            
    C-compatibility
        catoi          
        cprintf        
        cprints        
    Read-write
        set            
        set_ith        
        set_car        
        set_cdr        
    Reference
        deref          
    Dev
        rawmem         
        lusym          
        flush_cache    
        update_cache   
        copy_collect   
        bvm_root       
        dump_cache     
    Tags
        detag          
        get_tag        
        tageq          



X-Macro
-----------------

Looks useful:

http://www.drdobbs.com/cpp/the-x-macro/228700289


Native Parsing
-----------------

phase 1: 100% sexpr parsing

Semantics:

    [foo bar [baz bop] doo wop]

First, the text is converted into pure s-expressions

The s-expressions are then traversed depth-first

The first element to be evaluated above will be 'wop',
then 'doo', then the [] 'bop' then 'baz' then 'bar'
and finally 'foo'. First-elements will be recognized
and the list generated will be passed to the respective
keyword-processing function.

This shows how the Bipedal preprocessor will work. You
can freely define new keywords which will then be inserted
into the parser's internal symbol-table. A user-defined
keyword must accept an s-expression and must return a 
bstruct.


Local symbol-table
------------------

Create a unique symbol-table for each let-context


Backtracking
-----------------

    Two types of back-tracking: alternation and sequence

    Four operators: alt, seq, pass and fail

    -- Alternation

        x 
        ({a} 
         {b}
         {c})
        alt

        --> x is the backtrackable state
            if it is nil, the entire BVM is backtracked (except code_ptr)
        --> the list of code-lists ({a} {b} {c}) define the alternation

        First, code-list a is executed. Unless the pass-tag is on TOS when
            control returns from code-list a, x will be restored to its
            value prior to executing code-list a and then code-list b
            will be executed, and so on. The alt operator does not remove
            the pass-tag.

            If there is a fail-tag on TOS after executing a code-list it is 
            culled.

        If a code-list places the pass-tag on TOS, the alt "nexts" and
            normal execution continues.

    -- Sequence

        x 
        ({a} 
         {b}
         {c})
        seq

        --> x is the backtrackable state
            if it is nil, the entire BVM is backtracked (except code_ptr)
        --> the list of code-lists ({a} {b} {c}) define the sequence

        First, code-list a is executed. If the fail-tag is NOT on TOS, 
            then seq will execute code-list b WITHOUT backtracking x.
            And so on through all code-lists in the seq-list.

            If there is a pass-tag on TOS after executing a code-list it is 
            culled.

        If the fail-tag is on TOS when control returns from a code-list 
            x will be restored to its value prior to executing that code-
            list, the seq operator will "next" and normal execution 
            will continue. The seq operator does not remove the fail-tag.


stack-effect
----------------

Allow declaration of stack-effect...

("val" "val") ("val") { + } evalf


sort
----------------

General sort:

(list) {sort-compare-code} sort

Combines behavior similar to each with the merge-sort algorithm.

1. operands are removed from the stack
2. left/right lists are calculated and sort function is called recursively
3. whenever a comparison must be performed, the items to be compared
   are pushed on the stack, and the sort-compare-code is invoked. It must
   leave a true or non-true value on the stack
4. lists are merged ordinarily

Start with sortar

Substitution tags
------------------

REPLACE-ALL

[extern "foo"]

An extern tag permits the use of the interp operator to interpolate
a single value throughout a bstruct. Wherever the above tag occurs in 
bstruct b, for example, it will substituted with the value 7 by the 
following code:

b "foo" 7 interp

Doesn't work for string interpolation


Set vs. Replace
----------------

    There are actually two kinds of write: set and replace

    Replace overwrites memory at a given location

    Set changes a pointer to a new memory location


    Accessing inte elements and leaf elements for read is the same

    Leaf elements can only be written in REPLACE mode

    Inte elements can only be written in SET mode

    LEAF READ:
    [val 1 1 2 3 5 8] 4 th --> puts a copy of the 4th element on TOS

    INTE READ:
    [ptr [val 0 1] [val 2 3]] 1 th --> ptr to [val 0 1] on TOS

    LEAF REPLACE:
    [val 1 1 2 3 5 8] {4 th} 7 set --> [1 1 2 3 7 8]

    INTE SET:
    [ptr [val 0 1] [val 2 3]] {1 th} [val 4 5] set --> [ptr [val 0 1] [val 4 5]]

    LEAF SET: Undefined

    INTE REPLACE: Undefined

    Syntax consistency: Lists? Hashes? References? Tags?
        See "Setting" below

    Accumulation: 3 4 +=

    References and setting?

    Pre-indexed leaf-array thingie...
        Just create a tag


    Samuel discussion:
        Instead of: [val 1 1 2 3 5 8] {4 th} 7 set --> [1 1 2 3 7 8]
                do: [val 1 1 2 3 5 8]  4 th  7 set --> [1 1 2 3 7 8]

        To make this possible, track the last thing referred to by 'th'. This
        could get really complicated:

            [val 1 1 2 3 5 8]  4 th <- [ptr "hello"] 0 th << -> 7 set --> [1 1 2 3 7 8]
                                    ^^^^^^^^^^^^^\_/^^^^^^^^^^^
                                                  |
            should have no effect ----------------+

        On reflection, this proposal may simply be infeasible... :\

Auto-zap flag
----------------

Add a flag to enable/disable auto-zapping of operands

zapoff ... zapon

Syntactic sugar for this?

        cp^ === dup cp === zapoff cp zapon

Maybe...

Auto-copy
---------------
wva
Auto-copy of immediates in code-lists:

{ 1 2 + } --> { 1 cp 2 cp + }

Most of the time, this is wasteful and unnecessary, but
it is annoying when a loop doesn't work correctly because
you forgot to cp the immediate in the code-list...

Maybe something like this?:

    { {"hi " <<} 1000^ times }


Pearson16
-----------------

Babel> perl pearson.pl 'code_ptr'
05d66dc35e80a76d67b8d3eda64dd82d
                             ^^^
Babel> perl pearson.pl 'ustack_ptr'
ed0a4b3a6b5b9a61ed71e1ff4c7cf82d
                             ^^^

Probability is less than 2^-12 that this should occur by random chance...
plus both share the suffix '_ptr' which makes this even more remarkable.

Another massive collision:

Babel> perl pearson.pl main
9f6d01bab72c3d1a8f9cf5fa76732d47

Babel> perl pearson.pl text
769f3cd0c2b083276ec9263aef7e6e47

One solution is to do a second round, with an involution of indices to 
ensure mixing of randomness across the entire hash.

Another solution is to use Marsaglia's XOR32:

        y=(y<<13); y=(y>>17); return (y=(y<<5));

Add this as a post-processing step between rounds of Pearson16 to address
issues with observed statistical anomalies:


TPTR ops
--------------

Need to add operators to manipulate tptrs - such as get_tptr()


Operands
------------------

#define OI_MASK_NONE 1<<0
#define OI_MASK_LEAF 1<<1
#define OI_MASK_INTE 1<<2
#define OI_MASK_TPTR 1<<3

typedef struct { // operand_info#

    mword *data;
    mword *default;
    mword *mask;
    mword min_size;
    mword max_size;

} operand_info;

void get_operands1(operand_info *oinfo0);
void get_operands2(operand_info *oinfo0, operand_info *oinfo1);
void get_operands3(operand_info *oinfo0, operand_info *oinfo1, operand_info *oinfo2);


Data-flow
------------------

Data-flow will always be DOWN STACK. This is because operate-assign
operators only make sense in this configuration. Unfortunately, this will 
make mnemonics more difficult to remember but there is just no other way.

A B -   ==>    A-B
A B -=  ==>    A=A-B
A B set ==>    A=B


Setting 
------------------

    Lists:
        set_ith
        set_car
        set_cdr
        ins_ith
    Arrays:
        set
        paste


    my_converter: 

    [my_converter "Yo, what's up"]
    [math '((foo / 13) + 2 < 5)' ]

    <       setsym
    >       lusym
    <<      stdout      }
    >>      stdin       }----> These operators detect if TOS is leaf-array
    <<<     fprintf     }     ... if not, they _unload, then print/write
    >>>     fget        }

    .+      cat8
    @+      arcat
    %+      hash_merge
    $+      list_append
    <+      file_append

    @<      wrcxr
    @>      cxr

    %<      insha
    %>      luha

    $<      set_ith
    $>      ith

    .<      wrcxr8
    .>      cxr8

    .|      cut8
    @|      cut
    %|      diffha
    $|      part

    .=      strcmp
    @=      arcmp
    %=      hash_cmp
    $=      lscmp

    


TODO
---------

Fix hashes... (in order to fix flush_cache/set_sym)

MEMORY:

    mc_alloc
        -> _newlf
        -> _newlfi
            -> _newva
        -> _newin
            -> _newcons -> consa
        -> _newtptr

    no global mem

    bstruct->mem
    bstruct->mem_ceiling

REPL
    bvm_step
    parse.sp
BVM update (see below)
    Fix insha int _bvm_init - getting wrong hashes, missing values, etc.
babel operator: add operand for stack-init
Save-restore (kind-of done)
alternation

Memory management
-----------------

In order to get traction on Babel, going to settle for stop-and-collect GC.
A memory limit M will be set. The interpreter will allocate two pages (A 
and B) of size M/2 and begin working in page A. Allocations will occur in 
strictly linear order and there will be no deallocation. When the memory 
limit is reached, the interpreter will halt the program, unload it from page
A and load it now into page B and execution will resume in the same way until
the limit is again reached, ad infinitum. This is "Cheney's algorithm".

Eventually, some kind of incremental mem mgmt solution needs to be found.

Symbols, BVM-simple
-------------------

'/babel/tag/bvm_simple' tag will be used to denote a
BVM that stores its symbols as a list, rather than in
full symbol-table form.

Build flow
----------
http://www.cs.nyu.edu/rgrimm/teaching/fa05-oop/windows-make.html

References
----------

- Absolute vs. relative

A relative reference has nil as its first element. The reference
will then be indexed from the symbol table.

An absolute reference has a valid pointer as its first element 
and the lookup is performed on this pointer.

Bipedal syntax
--------------

    [] general s-expr
    () lists
    {} code

    [list 1 2 3] == (1 2 3)
    [code fnord] == {fnord}
    [val 1 2 3]
    [ptr 1 [ptr 2 [ptr 3 nil]]] == (1 2 3)

    "Hello, world" 'foo'     <
    "Hello, world"           <<
    "Hello, world" 'foo.txt' <<<
                   'foo.txt' >>>
                             >>
                   'foo'     >

    [ref 'foo' 1]

    ref uses "list-indexing"

    [refa 'argv' 1]

    refa uses "array-indexing"

    Default meaning of barewords is as references

    foo/bar --> [ref "foo" "bar"]

    Double-quotes: Backslash is the escape character: "Hello\n"
    Single-quotes: Slash     is the escape character: "Hello/n"

    This permits clean meta-programming since it is easy to quote
     one type of string literally with the other kind of quote:

        '"Hello\n"' <<
        "'Hello/n'" <<

    SUPER-COOL IDEA:

        What if we said that [] are not just "general s-expressions"
        but, in fact, a tptr POINTING to a general s-expression, 
        where the first element in the brackets is hashed to create
        the tptr hash. For example:

    [foo "Hello" "World"] --> Actually creates a tptr with the hash of
                                /babel/tag/foo and THIS points to the
                                s-expression containing "Hello" and "World"



List of HTTP client libraries
-----------------------------

http://curl.haxx.se/libcurl/competitors.html

Candidate: libfetch

crypto-library
--------------
http://libtom.org/?page=features&newsitems=5&whatfile=crypt


linking in Graphviz
-------------------

http://www.graphviz.org/content/how-use-graphviz-library-c-project
http://www.graphviz.org/doc/libguide/libguide.pdf

exec
-------------

http://www.cplusplus.com/forum/lounge/17684/

Windows:
    LPCTSTR lpApplicationName = "C:/Windows/System32/cmd.exe"; /* The program to be executed */

    LPSTARTUPINFO lpStartupInfo;
    LPPROCESS_INFORMATION lpProcessInfo;

    memset(&lpStartupInfo, 0, sizeof(lpStartupInfo));
    memset(&lpProcessInfo, 0, sizeof(lpProcessInfo));

    CreateProcess(lpApplicationName,
                  
    /* Create the process */
    if (!CreateProcess(lpApplicationName
                       NULL, NULL, NULL,
                       NULL, NULL, NULL, NULL,
                       lpStartupInfo,
                       lpProcessInformation
                      )
       ) {
        std::cerr << "Uh-Oh! CreateProcess() failed to start program \"" << lpApplicationName << "\"\n";
        exit(1);
    }

    std::cout << "Started program \"" << lpApplicationName << "\" successfully\n";


Linux:
    char* programPath = "/bin/bash";

    pid_t pid = fork(); /* Create a child process */

    switch (pid) {
        case -1: /* Error */
            std::cerr << "Uh-Oh! fork() failed.\n";
            exit(1);
        case 0: /* Child process */
            execl(programPath, NULL); /* Execute the program */
            std::cerr << "Uh-Oh! execl() failed!"; /* execl doesn't return unless there's an error */
            exit(1);
        default: /* Parent process */
            std::cout << "Process created with pid " << pid << "\n";
            int status;

            while (!WIFEXITED(status)) {
                waitpid(pid, status, 0); /* Wait for the process to complete */
            }

            std::cout << "Process exited with " << WEXITSTATUS(status) << "\n";

            return 0;
    }


list operators
--------------

(a) (b c d)   append  --> (a b c d)
(a b c d) (1) part    --> (a) (b c d)
(a) (b c d)   cons    --> [(a) (b c d)]
(b c d) (a)   push    --> (a b c d)
(a b c d)     pop     --> (b c d) (a)
(a b c) (d)   unshift --> (a b c d)
(a b c d)     shift   --> (a b c) (d)

----- part -----

(a b c d) nil part -> (a b c d)
(a b c d) (0) part -> ( nil (a b c d) )
(a b c d) (1) part -> ( (a) (b c d) )
(a b c d) (4) part -> ( (a b c d) nil )
(a b c d) (1 3) part -> ( (a) (b c) (d) )

----- memory discipline redux -----

1) Interpreter service memory
    - can be deleted at interpreter's whim
        [udr]stack, code-list, symbol-table, etc.
        Babel program should never get access to these pointers
2) User "new" memory (hard manual memory)
    - lifetime = BVM lifetime, or until user deletes
    - equivalent to C++ new/delete discipline
3) Operator-created memory
    - lifetime = eval-context lifetime

What happens when memory-types mix?
    - e.g. cons/push/unshift
    - Whole object gets the weakest memory type

User can override lifetime of item on TOS by using
the immortal operator. 

Note that cp operator does not yield immortality, you
must apply the immortal operator to make the copy 
immortal.

----- Babel "functions" synopsis -----

goto -> simple branch  

    foo goto

eval -> branch with return

    foo eval bar   -- (returns to bar after doing foo)

up/down -> Permits movement between the ustack and dstack

nest -> Permits "nesting" to allow a function to monopolize the stack

take -> Permits the use of "lexical" variables
    Better performance than full-blown symbols and better clarity 
    than stack operations for certain kinds of operations

give -> Opposite of take

---- sparse: lexical vs. symbols ------

    Bare-word: lexical reference
        
        foo

    $-sigil: symbolic

        foo$ (gets turned into a reference)

        shorthand for: (ref 'foo')

Example:

    bar$: 
       ^This means "enter a pointer to this in the sym_table"

    foo:
        { (a b c d) take
            a b *            a is really foo/a LEXICAL ONLY
            a c * +
            b d * +
            c d / +
            b c * + } <-- this gets put in foo/_bstruct LEXICAL ONLY

    If a, b, c and d don't refer to anything, they are just initialized 
    to nil by sparse.

    { a$ << }
      ^Data-reference

    { "foo" a! }
            ^Code-reference (gets eval'd)

    { a ! }
      ^ ^ 
      | eval operator
      lexical

    { a$ ! }
      ^  ^ 
      |  eval operator
      Data-reference

----- take -----

Currently take can only accept a numeric argument. If take is given
a list as argument, it will take the length of the list's worth of
items off the stack and modify the list to place pointers to the
stack items in the given list:

    ( a b c ) take

Now, a points to what was TOS, b to what was TOS-1, etc.

----- sparse: macros -----

( X .... )

X -> list type

Permit "macro" lists:

(macro 'foo' ...)

... -> equivalent to contents of a Babel code-list (code ...)

EXAMPLE:

(macro 'foo' shift reverse)

(foo a b c)

1. The list (a b c) is placed on TOS
2. The list is shifted leaving (b c)
3. The list is then reversed leaving (c b)
4. (c b) is now substituted back into the "parse-tree"
   where (foo a b c) had been.

----- code re-structuring -----

"babel_op" macro

store function pointer in rstack for end-condtion of flow-control 
operators

----- bvm organization -----

bvm (tlist) -> encodes compatibility
hard_root (tlist)
    bvm_code (tlist)
    bvm_stack (tlist)
    jump_table (tlist)
    sym_table (tlist)
        hash
            /runtime
                /env
                /hdd
                /network
                /alloc
                /tag
                /etc
            /persist
                /self (soft_root)

bvm_code
    code
    rstack

bvm_stack
    dstack
    ustack

sym_table
    hash_table

jump_table
    list (opcodes)

----- packages -----

Imagine we have a file - A.bbl - containing the following relative structure:

foo:
    bar:
    baz:

Now, let's say we want to install this structure at /frob:

/frob "A.bbl" >>> set

We should now have the following:

frob:
    foo:
        bar:
        baz:

This is "package-ness" - the paths used in A.bbl are relative, not absolute.

----- Damian Conway's Perl6 EXPORT -----

Implements what I hope the Perl 6 symbol export mechanism might look like.

It's very straightforward:

-   If you want a subroutine to be capable of being exported (when explicitly
    requested in the use arguments), you mark it with the is export trait.
-   If you want a subroutine to be automatically exported when the module is 
    used (without specific overriding arguments), you mark it with the 
    is export(:DEFAULT) trait.
-   If you want a subroutine to be automatically exported when the module is 
    used (even if the user specifies overriding arguments), you mark it with 
    the is export(:MANDATORY) trait.
-   If the subroutine should also be exported when particular export groups 
    are requested, you add the names of those export groups to the trait's 
    argument list.

----- linking (usage models) -----

* at invocation-time (explicit) - a .bbl file can be loaded at 
  invocation-time through the command-line (namespace merge)

* at invocation-time (implicit) - a .bbl file can be loaded at invocation-
  time during the compilation process (static linking)

* at run-time (explicit) - a .bbl file can be loaded at run-time by using
  the load command or during compilation

* at run-time (implicit) - a .bbl file can be loaded at run-time by 
  encountering an unresolved reference in the running bvm
  - regular reference -> (namespace merge)
  - static link -> on-demand static link

----- linking -----

Dynamic vs. static

Suppose we have two .bbl files, A.bbl and B.bbl and that one file
contains references to namespaces that exist in the other. The process
of linking these together is called static-linking.

Suppose we have a .bbl file, C.bbl and that it contains references
to namespaces in the running BVM. The process of loading C.bbl is called
dynamic-linking.

A (dynamic or static) link is denoted by a special kind of reference 
called a link-reference. Unresolved link-references in the running BVM are 
dangling-references and can cause the interpreter to exit the BVM should
it encounter the dangling-reference during execution.

Babel employs a unique method to avoid "name-mangling" in object files:
every .bbl file which utilizes linkages should follow this naming
convention:

/<domain-name>/<var-name>

You should use a registered Internet domain-name that you own or control
to root your symbolics. This has two benefits. First, it makes it unlikely
that there will be namespace collisions among linkages. Second, it creates
a way for unresolved linkages to be troubleshot. You are free to manage
your library names and variables names as you see fit within your domain-
name space.

----- env vars -----

http://msdn.microsoft.com/en-us/library/windows/desktop/ms683187(v=vs.85).aspx

void print_env(void){

    char *l_EnvStr;
    l_EnvStr = GetEnvironmentStrings();

    LPTSTR l_str = l_EnvStr;

    int count = 0;
    while (1)
    {
        if (*l_str == 0) break;
        while (*l_str != 0) l_str++;
        l_str++;
        count++;
    }

    int i;
    for (i = 0; i < count; i++)
    {
        printf("%s\n", l_EnvStr);
        while(*l_EnvStr != '\0')
            l_EnvStr++;
        l_EnvStr++;
    }

    FreeEnvironmentStrings(l_EnvStr);

}

----- color tags? -----

ref-list has type-indicator per list entry

- re-summary of bstruct

    pointer always points at first data entry
    X.s @ pointer-1
        X.s < 0     interior array
        X.s > 0     leaf array
        X.s = 0     tagged list

    A tagged-list is a Lisp-style list that begins with a "tag" that is
    intercepted by the Babel interpreter. A tag is just a 128-bit hash.
    While the tag can be used to implement typing, it should not be 
    thought of as a type per se.

----- Syntax rework -----

 [] -> array brackets (pointer or value... eventually)
 () -> pure list brackets
 {} -> tagged-list brackets

The tagged-list brackets can emulate the other brackets:

    { list ... }  <==> ( ... )
    { ptr ... }   <==> [ ... ]  (pointers)
    { val ... }   <==> [ ... ]  (values)

Basically, tagged-list is basically Babel's version of an S-expr.

The namespace syntax can be constructed with tagged-lists:

    foo:
        bar: nil
        baz: nil

        <==>

    { name foo { name bar nil } { name baz nil } }

You can surround valid Babel with an ign tagged-list to ignore it:

    { ign ... }

To create a code-list:

    { code ... }

To create a bvm:

    { bvm ... }

To create a reference list:

    { ref ... }

This is how nil is actually implemented: { ref nil }

The full tag that gets hashed is: /babel/tag/<tag-name>

----- Reference re-design -----

Ideally, the "look-up" syntax should be able to traverse anywhere in a
bstruct.

Propose: Two types of reference - compile-time and run-time

Compile-time references just use "plain name" syntax:

foo.bar/baz[10 3](17 5)/bop

Propose: To implement run-time references, the meaning of X.s == 0 is changed

Instead of containing a single hash-reference, it indicates this points
to a reference-list.

A reference-list is constructed in Bipedal using the <> brackets.

<foo%>

... performs a dynamic reference to foo. The syntax is like any other list.

The first element of an auto-lookup list can be a pointer. If it is not
a pointer, then the root-namespace is used for the first hash-lookup 
(if any).

Successive elements can be:

    - A single value
        Would be nice to be able to look up via string (auto-hashing)
    - A hash
    - A "nested" auto-lookup

< foo < bar > >

< foo& < bar > >

The () and [] are just syntactical sugar - (3) just translates to [1 1 1 0]

Directory syntax

There are two kinds of "directory" structure in Babel. The first is
"static" directory and the second is dynamic directory. The static 
directory is indicated by the dot-separator:

foo.bar.baz

The dynamic directory structure is indicated by the slash-separator:

foo/bar/baz

The two syntax forms can be mixed:

foo.bar/baz

/foo/bar   --> dynamic dir look-up starting from root-namespace
/foo.bar   --> static dir look-up starting from root-namespace
foo/bar    --> dynamic dir look-up, relative to current-namespace
./foo/bar  --> same
../foo/bar --> same, but accessing parent-namespace
./foo.bar  --> static dir look-up, relative to current-namespace
foo.bar    --> same

Nested, relative, file-relative namespace look-ups

foo:
    bar: 3
    baz: { bar << } --> Works

block vs. flow syntax for directories and namespaces
: vs. = (rwx)

----- Stack re-work -----

One final (hopefully!) stack re-work needed... the following code works
on the current implementation but the programmer shouldn't need to wrap
everything with an extra pair of brackets. Hence, we need to add in an
extra indirection for every item on the stack so that set/paste/etc. work
correctly.

To accomodate the change, the proto-Babel syntax will be updated 
slightly, as well.

foo: 13

This actually creates:

foo: [13]

... in present syntax.

The star operator will be used to indirect as needed:

(foo* 2 3)

By default, this will work fine in code-context:

(foo show cr <<)

----- Hard vs. soft operator names -----

Some operators (such as print) should have a "soft" definition that
can change over time, i.e. as pseudo-operators. Others should have a
definite meaning no matter what (hard).

----- Make operators empty stack safe -----



----- bstruct find -----

finds all occurrences of a pointer in the entire BVM

Use this to safely remove a bstruct which has untracked references
scattered through the machine.

----- bstruct diff'ing -----

x y everything_in_x_and_not_in_y
    Need just one LSB
x y everything_in_both_x_and_y
    Requires two LSBs

The or is basically cons

- Left-complement
    Uses only one LSB. First, x is marked dirty with the rdirty() function
    Then, y is traversed (and do what?)
    Then, both x and y are cleaned.

- Intersection
    Use two LSBs
    x is traversed with LSB
    y is traversed with LSB+1
    Next, y is traversed looking for entries with both LSB and LSB+1 set

----- Hash-refs -----

Do it!

----- if/ifte/cond/sel -----

current if is totally confusing

We almost invariably dup the TOS in the conditional

"if" Propose:

    Encapsulate the conditional (ala while)
    Eliminate the "then"

    { 0 > } { "greater than zero!" << } if
     ^
     | 
     dup is inserted and performed automatically - if this is a problem
    it can always be zap'd

"ifte" Propose:

    { 0 > } 
    { "greater than zero!" << } 
    { "not greater than zero!" << } 
    ifte

"cond" Propose:

    { { 3 > } { "greater than three!" }
      { 2 > } { "greater than two!" }
      { 1 > } { "greater than one!" } 
              { "greater than something!" } } --> Note the default condition
    cond

Note: auto-dup'ing included in ifte and cond

sel:

    Do we need it? With if+up/down we can emulate sel without the 
    confusion about what is being selected

    Propose: eliminate it

----- Test structures -----

Many Babel operators exactly undo each other. E.g.:

    unload load
OR
    dup # <- `1 rand -> % cut cat
    `( dup zap ) `1 rand 1000000 % times

We can implement a limited form of randomized testing by nesting such 
operators and sprinkling in random bstructs:

x A A' ---> check for x
x { A A' } eval ---> check for x
x A B B' A' ---> check for x
x A B B' C C' A' ---> check for x
x A y B B' A' ---> check for x y
etc.

A random test-harness will turn up lots of corner-case bugs and greatly 
increase confidence in Babel's overall health and robustness.

----- memory management redux -----

How memory comes to be:

1. Initial object load
2. Copy from code object onto stack (ducp)
3. User-initiated copy (cp)
4. User-created memory (new*)
    -> new* always returns a HASH-REF
    -> ref-counted
5. Lexical memory (let)

let -> automatic variables (lexical or symbolic)
new -> symbolic variables (user doesn't get pointer), ref-counted

context -> declares a stack context, does not nest
nest -> also declares a stack context; nests

sweep -> mark-and-sweep performed at end-of-context

keep -> promotes memory in current context to next higher context

Dealing with duplicates:

    - Duplication is controlled through the use of REFERENCES (pref)
    - let creates references
    - references are purely conventional
    - When a reference is freed, it is replaced with nil

    MEMORY THAT CAN BE AUTO-FREED MUST BE POINTED AT FROM ONLY ONE PLACE
    ALL OTHERS MUST BE REFERENCES OR MANUALLY MEMORY MANAGED

Conclusion: Besides the stack, the BVM is itself the primary unit of
memory-management. The BVM can "save/restore" itself at any point in
order to get a fresh allocation when it hits its memory usage limits.

----- backtracking: -----

http://www.akira.ruc.dk/~keld/research/CBACK/CBack-1.0/DOC/CBACK_PAPER.pdf

From Wiki:

    Pseudocode

    In order to apply backtracking to a specific class of problems, one 
    must provide the data P for the particular instance of the problem 
    that is to be solved, and six procedural parameters, root, reject, 
    accept, first, next, and output. These procedures should take the 
    instance data P as a parameter and should do the following:

        root(P): return the partial candidate at the root of the search tree.
        reject(P,c): return true only if the partial candidate c is not worth completing.
        accept(P,c): return true if c is a solution of P, and false otherwise.
        first(P,c): generate the first extension of candidate c.
        next(P,s): generate the next alternative extension of a candidate, after the extension s.
        output(P,c): use the solution c of P, as appropriate to the application.

    The backtracking algorithm reduces then to the call bt(root(P)), where bt is the following recursive procedure:

     procedure bt(c)
       if reject(P,c) then return
       if accept(P,c) then output(P,c)
           s <- first(P,c)
       while s != lambda do
         bt(s)
         s <- next(P,s)

Also consider best-first search.

alt is the DFS operator

    (save_restore_list) ( a b c ) alt

CBack uses the term "merit" for BFS. Consider:

        (save_restore_list) 
        ( (merit_a a) (merit_b b) (merit_c c) ) 
    altm --> m for merit

Merit could just be a literal number to act as a "biasing" mechanism but 
it could also be a variable (more like a Markov tree).

----- macro-substitution -----

We can use hash-references to implement a kind of substitution that can
be used to implement Lisp-style macros (among other things):

foo: { x& 2 += } -- adds 2 to x&

If executed, foo would dynamically fetch x from the symbol table. But 
what if we just want to substitute the value as a constant?

foo: { x& 2 + }

main: { ((x& 3)) foo macsub } --> performs a macro-substitution on foo

TOS now contains: { 3 2 + }

... which can then be eval'd. Of course, we could have substituted a
structure of any level of complexity.

Limitation: 
    You can't use macro-substitution inside of leaf-arrays.

----- magic namespaces -----

(meh)

foo  : 3
bar= : 3
baz! : { 3 }
bop% : 3
doo* : 3

By appending a magic sigil to a namespace name, you tell BPDL to impart some
magical property to that namespace. You only append the magic sigil when
DEFINING the namespace, never when USING it.


foo     -> standard namespace entry in the dynamic symbol table
bar     -> static (C-style static) lexical variable (doesn't get 
            pushed/popped on rstack)
baz     -> auto-invoked (eval is always appended after each occurrence
bop     -> auto-hash-ref'd (%% operator is always appended)
doo     -> in-place-expanded - type of expansion (list, interior, leaf) 
            depends on what comes after the colon
        Not sure this makes sense

----- code-list syntax -----

BPDL will provide a "code-list" syntax. Unlike proto-Babel, the {} will not be 
used to denote leaf arrays - instead, the [] will be made "smart" (more details 
needed).

main: { 2 2 + << }  --> what a naive user expects to see
main: ( `2 `2 + << ) --> what you actually have to write

Because a bstruct is a generic data-structure and BPDL is just a syntax
for describing bstructs, we cannot restrict BPDL to code-list syntax.
However, we can provide code-list syntax as a convenience.

The rules of code-lists:

    - everything except operators are automatically enclosed in parens:

        { 1 2 3 4 } <==> ( `1 `2 `3 `4 )
        { "Hello, world" << } <==> ( `"Hello, world" << )

        { x 0 >
            { "not greater" << }
            { "greater" << }
        if} 

        ( `x `0 >
            `( `"greater" << )
            `( `"not greater" << )
        if) 

        { (1 2 3) { %d " " . << } ... }
        ( `(1 2 3) `( %d `" " . << ) ... )

    - every "literal" value is stack-copied instead of stack-dup'd (we really
    need to create an operator for this)

        { { 1 1 += } 10 times }

            ==>

        ( `( `1 ducp `1 ducp += ) `10 times )

    Note: ducp ==> cp <-> zap

    - auto-discrimination

        a: { 2 + }
        b: "Hello\n"
        foo: { 3 a! b << << }

        ==> Because a is defined as a code-list, BPDL assumes any reference
        to it is meant to be eval'd (um, what about in ifs, whiles, etc.??)

    - stack operand-checking

        "req_lf_lf" operators will be inserted before each regular operator to 
        check the state of the stack. If you want to program more "dangerous"
        but faster code, just use the pure list syntax.

    - constant-folding and {}

        {} code-lists are automatically cfold'd :

            { 1 2 + } ==> ( `1 `2 + ) cfold ==> 3

----- lexical variables ----

    A lexical variable exists only within a specified context. Lexical variables
    are like "named registers" in a register-VM or reference in C++/Perl.

    Each invocation of a context creates a new instance of the variables.

        (x y z) ( <code> ) let
    
    TOS-1 has a list of lexical variables. Note that these exist as actual 
    space in the obj, kind of like "registers". The let simply connects the 
    registers to their current location on rstack (as well as saving/restoring
    their prior value).

    Step 1:

        Allocate a "let" entry on the rstack, with 3 spaces to save prior value 
        of x, y and z.

    Step 2 (args):

        Overwrite x, y and z with pointers to their stack entries and remove
        from stack.

    Step 3:

        On destruction of the current context, pop rstack and restore x, y and
        z

    foo: { (a b c) { a b + c + c set } let }

    What about write-back, are there hidden issues here?

    Nested let:

    foo:
        { (a b c) 
        { (x y z) 
        { a x + 
          b y + 
          c z + 
          a set b set c set 
        } let } let }

    No advantage to doing this but might occur due to evals.

        foo/a foo/b ... foo/z

    Who is in charge of managing the namespace?

    - Using lexicals in code-list vs. list notation

    foo: { (a b c) { a b + c + c set } let }

    foo: ( `(a b c) `( a caar b caar + c caar + c caar set ) let )

----- cp/dup of code-stream operands -----

Currently, we simply push_alloc each operand onto the stack as it is encountered
in the code-stream. But consider the following code-snip:

    `( `1 `1 += ) `10 times

The second `1 operand will be modified by the += operator on each pass through
the loop. This is clearly undesirable behavior.

One option is to perform a cp of each operand as it is encountered and pushed
onto the stack. However, there are clearly situations where this is unnecessary
and wasteful:

    { { "Hello, world" << } 10 times }

... now imagine we had a very large block of text or some other kind of data.

Also, we need to figure out how to handle variables:

x: "Hello, world"

main: { x << }

----- BPDL -----

- in-place expansion

a : 3
b = 3

c : "3"
d = "3"

e : [3]
f = [3]

g : (3)
h = (3)

i : {3}
j = {3}

k: [ 1 2 a ] --> [1 2 3]
l: [ 1 2 b ] --> [1 2 b] b "takes up space"

m: [ 1 2 e ] --> error
n: [ [1] a ] --> error

o: [ [1] [2] e ]   --> [ [1] [2] [3] ]
p: ( 1 [2] a b c d e f g h i ) --> OK
q: [ [1] g ] --> OK
r: [ [1] i ] --> OK

s: [ 1 2 *e ] --> [1 2 3]

t: { 4 a set } --> error, can't assign to literal '3'

u: ( 1 2 a ) --> ( 1 2 3 )
v: { 1 2 a } --> ( `1 `2 `3 )

- choose the right default for barewords

    lexicals (pointer aliases)
    symbols (hash-references)
    tokens (#defines)



----- beyond mortality -----

Current method just assigns each value on the stack as mortal or immortal.

What we really need is a way to say "this thing cannot be freed until
such time as we have left such-and-such context". So, we have three grades
of mortality:

1) Immortal -> never gets freed
2) Demimortal -> not freed so long as its context is in the live_list
3) Mortal -> always freed as soon as it is used

We should maintain the live_list as a binary tree (or hash table).

When are contexts created/destroyed?

An eval obviously creates a new context. A nest should also create a new
context. Loops and if should NOT create a new context.

We need a concept of "current context" - whenever something is created on
the stack, it inherits the current context. The current context could just
be a 128-bit random number. 

Every live context is inserted into the live_list. When a demi-mortal 
item is removed from the stack, the live_list is probed with that item's
context ID. If it is not present, then the item is freed.


----- transpose -----

----- RMW -----

Imagine traversing a leaf array and adding one to each entry.

No current way to do this IN PLACE. Think about ways to do this.

----- Rethinking rstack/stack operators -----

Currently, up/down/nest use the rstack. However, when performing a
next, we don't necessarily want to pop off all the down items
which have been placed on the rstack - IOW, up/down are orthogonal
to control-flow usage of the rstack.

Proposal: Create a third stack called ustack. Ustack is where the
up/down operators will work.

More thoughts on nesting:

The primary benefit of the auxiliary stack is it make it easy to move
"up and down" the main stack. "Nesting" is basically switching stacks - 
but where do we save the ustack? Perhaps save both stack and ustack
onto the rstack when nesting? Suppose we don't want to unnest when 
returning from an eval?

    (1 2 3)
    nest
        <do stuff on the stack> 
    unnest
    TOS --> (a b c d)

Some more stack operators:

    top -> empties the ustack onto the stack
    bottom -> empties the stack onto the ustack
    turn -> switches the stack and ustack pointers

    empty?: ((  stack nil? ))
    full?:  (( ustack nil? ))

Also, give and take need to be re-thought.

Give is easy to do with a foreach.

    give: (( `( nil ) ... ))

Take is more difficult and requires a while.

But whenever we do a foreach, the first element will be buried at 
the bottom of the stack. When we take the whole stack, we really want
the bottom of the stack to be the FIRST element of the resulting list.

This is how give/take currently work.

Implement dig/bury

----- stack persistence/data-types -----

Currently, we mark the stack type with the opcode of the last operator
to operate on the stack item. The key purpose is to determine whether
the stack item should be zap'd or hard_zap'd when it is consumed.

In Babel 2.0, we want to have a kind of "type system" that can invoke
an appropriate destructor whenever removing an item from the stack. So,
we will need to know TWO pieces of information: Whether to invoke a
destructor and which destructor to invoke.

We separate operators into two types. The first type are operators that 
do not manipulate the stack and create output which CANNOT have a pointer 
into its input operands. The output created by these operators is called 
stack-independent. This means that each of the input operands can be 
freed if it is marked as stack-scoped. By default, these operators always
mark their output as stack-scoped. This can be changed with the persist
operator.

The second type are operators that create output that CAN have a pointer
into one of the input operands (e.g. cons) or manipulate the stack. These 
operators produce stack-dependent output.

Stack-dependent operators never zap their inputs but propagate their
stack-scoping according to the following rule: if ALL inputs are marked
as stack-scoped then the output will be marked as stack-scoped, as well.
Otherwise, the output is marked as persistent.

----- single vs. double-pointers -----

Consider

    `1 `2 +

This takes two immediate operands on the stack and produces a stack-
immediate result.

Def'ns

From the interpreter's point-of-view, everything is just pointers.

It is the operator which determines whether something is an immediate/etc.

    `x `2 +

This still works because '+' will never need to alter x itself to point
to a different location.

Where this breaks down is with any operator that may need to modify one
of its source operands in-place.

    `x `(2 3) push

If we modify it to treat x as a double-pointer, then we clutter the
immediate syntax:

    ``(1 2 3) ``(4 5 6) push

We can treat x as a storage location from which we're pulling things onto 
the stack and then saving them back again.

    `x `(4 5 6) push `x set

However, this runs into trouble when initializing x.

This will be left as an open problem for now until after hash-refs
are implemented. 

----- unload/cp -----

Re-enable these in preparation for alt/back

Re-enable exha/luha (no rmha for now)

Plumb in insha support into proto_babel.pl

/code
/stack
/sym_table

----- jump_table -----

Implement jump table before re-enabling rstack

----- READ/WRITE -----

    x dup 4 th 4 set

Array:
    Read:
        th/trav
        `[1 2 3 4 5] `4 th --> 5
        `[ [1 2] [3 4] [5 6] ] `(1 0) trav --> 3
    Write:
        set/move
        [1 2 3 4 5] 7 4 set --> [1 2 3 4 7]
        `7 `[ [1 2] [3 4] [5 6] ] 
            --> [ [1 2] [7 4] [5 6] ]

List:
    Read:
        ith/walk
        `(1 2 3 4 5) `4 th --> 5
        `( (1 2) (3 4) (5 6) ) `(1 0) trav --> 3
    Write:
        write
        `7 `( (1 2) (3 4) (5 6) ) `(1 0) write
            --> ( (1 2) (7 4) (5 6) )

Hash:
    Read:
        lu/probe
    Write:
        ins

Hash-reference:
    Read: (just use it)
    Write:
        set
        `0 &x set

----- bstruct.c stuff -----

Need to move bbl2gv() and related functions to bstruct.c

Also, need to implement an is_bstruct() that can check a relative-offset
bstruct.

----- car/cdr with hash-refs -----

car() and cdr() can't handle hash-refs. This will have to be fixed.

for nil-safety, use scar() and scdr()

may use hcar() and hcdr() for general hash-ref-safety

----- eval of namespaces -----

`"foo : 3" compile load !

What happens?

This probably goes back to the whole issue of creating a BVM - what does
it mean for something to be a BVM?

How come I can eval this:

    `(foo 3 set) !

But not this:

    `"foo = 3" compile load !

?

----- local/global namespace look-up -----

In a given "loaded scope", need a way to make everything in that scope
relative to its own base, rather than the sym_table.

By default, lookup is in the sym_table. Need a syntax to say "don't 
start at the sym_table, start wherever it is I was loaded at".

This should be done with RELATIVE ADDRESSING:

a:
    d:
    e:
    f:
        g:
        h: ./g --> Note that . refers to F not H
        i: ../e
        j: ../../a --> etc.
b:
c:

----- BHIS -----

Big Hairy Indexing Syntax

Serious syntactic issues with this:
`({foo/bar} {baz/bop} (3 5) (7 11) {biz}) @

BUT

we could make it built-in

/foo/bar --> This is just a plain, undecorated variable name
            no fancy stuff - flat lookup in single hash table
/foo{bar} --> Two steps, first look-up in the immutable hash-table
            then look-up in a mutable hash-table
/foo(1) --> look up immutable, then look up list

/foo(1)(3) --> look up immutable, then perform a trav

/foo[1] --> look up immutable, then array look-up

/foo[1][3] --> look up immutable, then perform a walk

/foo{bar}(2)(4){baz}[6][8]{bop} -- etc.

Need syntactic way to distinguish whether a lookup is mutable or immutable

- Quotes or no quotes:

/foo/bar{baz/bop} --> two lookups in immutable namespaces

/foo/bar{"baz/bop"} --> one lookup in immutable namespace, one in mutable
                        namespace

----- parent BVM calls -----

We currently have the bvmbreak operator which allows an "exit" to the 
parent BVM. We want a way to be able to invoke parent BVM functions.

- Rename bvmbreak to conjure

We can treat a bvmbreak as any kind of exception that cannot be handled
by the current BVM and causes an exit - a hash-reference is pushed on
the stack to indicate the exception type. So, to invoke a parent 
function:

gc& conjure  --> Conjures the garbage-collector

----- immutable namespaces -----

Need a syntax for this.

Immutability of namespaces is orthogonal to RWX of the namespace contents.

Determined by use of curly brackets:

foo : 3 --> const, immutable
foo = 3 --> variable, immutable
{'foo' 3} --> variable, mutable

const, mutable doesn't make any sense

You can insert into immutable namespaces but no moving/deleting or
recursive copy (?)

----- namespace operator, default namespace, hash-refs -----

The namespace operator sets the default namespace. If it is called with
nil on TOS, the default namespace becomes self.

    [nil] namespace     --> sets default namespace to self
    [A] namsepace       --> sets default namespace to A

The default namespace determines where hash-refs are looked up.

foo:
    bar: (when I say 'baz' here, I want it to mean /foo/baz, not /baz)
    baz:
baz:

----- self -----

#Rename bvmroot to self

----- nil as a hash-ref -----

Note: We still need at least ONE nil present in the interpreter - this
nil is created at reset and is never destroyed and is called "global_nil".

It can be used across threads but not across processes.

----- bounding hash-refs -----

A hash-ref may be either bounding or non-bounding. This determines whether
Babel's recursive built-ins will continue recursing (non-bounding) or not 
(bounding).

This is planned as a Babel 2.0 feature...

----- hash-ref guts -----

The actual entry in the hash for a hash-reference needs quite a bit of meta-
data:

    (value ref-count bounding R W X)

----- linking ------

Linking is solved by consistent use of hash-refs. For example, when unloading
a list, nil is a hash-ref so it doesn't need to be unloaded. To ensure this, 
lists will reference nil using a hash-reference instead of a direct pointer.

The bounding field of the reference entry determines whether the load/unload
operators will stop recursing at hash-ref boundaries; this is the same for all
recursive Babel operators.

For situations where you might want to do:

    {1 2 x}

... do this instead:

    ( 1 2 x& ) ls2lf

----- RWX syntax -----

The Babel namespace will have RWX controls.

The three primary combinations of interest are:
    Rwx
    RWx
    RwX

Each will have a corresponding syntax -

read_write_data =  (1 2 3)
read_only_data  =: (1 2 3)
code : `"Hello, world" <<

The colon creates a code-block. There are some syntactical differences
with the code-block. It auto-wraps the entire block in parens. 

code :   `"Hello, world" <<
code : ( `"Hello, world" << ) <-- effective meaning

code : `2 `3 + %d <<

----- list evaluation -----

WRONG:
    ``! 
    `( `1 `2 ( `3 `4 * ) )
    ...
collect

----- quick-wrap syntax -----

Often, the need arises in Babel to "wrap" an item in multiple 
parentheses. These parentheses are visually redundant (but necessary
for semantic correctness). The quick-wrap syntax provides a less
visually cluttered alternative:

    The following are all equivalent:

    (((1 2 3)))
    `((1 2 3))
    ``(1 2 3)

    For single items, you can use the back-tick directly:

    ````1
    ((((1))))

    `"Hello, world"
    ("Hello, world")

----- relative/absolute paths and namespaces -----

The *ns operators will differ from the *ha operators in the following 
ways:

    - *ns operators expect a list of lookups
    - lookup by path instead of hash
        - This is necessary to determine local versus global lookup

----- extended types and "default" namespaces -----

We currently use the opcode number to set the "type" of operands on the
stack. We can extend this by converting from opcode number to a hash-
reference. 

The hash-reference can double as a look-up into the sym_table
as a "default namespace" for the next operator in the code-stream.

What this does is confer "Ruby-like" namespace management to Babel. If
you create put a string on TOS, then the default namespace will be
/babel/string and the subsequent operator (say, cat) will have to be
accessible from /babel/string.

This is planned as a Babel 2.0 feature.

----- collect -----

This is a loop operator that is sort of the inverse of each. After each 
iteration, TOS is collected into a list. The collected list will be left 
on TOS.

        ((loop_body))
        ((cond_block))
    collect

The collect terminates when cond_block leaves false on TOS

----- transpose -----

    We will not have a MAP or ZIP operator

    --
        (( 1  2  3  4 )
        (  5  6  7  8  9 )
        (  10 11 12 13 14 15 ))
    transpose

    --> ((1 5 10) (2 6 11) (3 7 12) (4 8 13) (nil 9 14) (nil nil 15))

----- set -----

Equivalent to [0] cxr:

    [3] x set --> x now has 3

----- parsing -----

Use alt/back. 

The parse-tree and pointers into the string being parsed will be kept 
in the save_state area (we can probably descend the parse-tree so 
save/restore is quick).

Create a $0 variable that contains "this namespace" so we can insert
into the parse-tree by name and track whether we've visited this namespace
before at this pointer into the string being parsed (PEG).

----- walk/write -----

Like trav but for lists.

( 'a' ('b' 'c' ('d' 'e') 'f') 'g' 'h')
[(1 2 0)] walk --> yields 'd'

write is like paste but for lists:

['i']
( 'a' ('b' 'c' ('d' 'e') 'f') 'g' 'h')
[(1 2 0 0)] write --> yields ( 'a' ('b' 'c' ('i' 'e') 'f') 'g' 'h')

----- alt/back -----

( save_state& )
( alt_list )
alt

The save_state is restored after each back and control transfers
to the next element of the alt_list. Once an alternative completes
without back-tracking, the alt operator itself is finished and 
execution proceeds.

----- File extensions -----

If the file ends in .bz2, Babel will automatically unzip the file. So
you can store your Babel files in zipped form with no hassles.

Once unzipped, Babel will attempt to interpret the input file as a 
compiled file. If the input file is not a compiled Babel file, it will 
fail. Then, Babel will try to interpret the file as uncompiled code 
(script).

Switches will be included to force Babel to interpret the file in a
particular way or fail.

----- CLI/stdin/stdout/nesting/etc. -----

The babel operator invokes a sub-instance of the babel interpreter.

To keep things consistent with the external world, implement the following
structure:

On invocation:
- Check stdin
    - if non-empty:
        read and place lines on stack
        unless user uses a switch to say "don't do this"
    - If empty, check command-line
        perform CLI auto-parse:
            TOS contains a list of all default arguments - if no default
            arguments, nil
            TOS-1 contains a hash with each CLI parameter and the 
            argument following it, if any. Can handle --switch,
            -switch=1, etc. Can't handle flags but those can be 
            decoded by hand.
        unless user uses a switch to say "don't do this"

You can do the same thing when starting a sub-instance of Babel:

    ["foo.bbl"] >>> load
    [(1 2 3)] <-- whatever is here will be give'd to the child
                        babel's stack; if nil, nothing is pushed
    babel

Whatever is left on the stack after execution is considered the
return value of the program and is pushed on the parent's stack.

Use the bbl operator to just launch/exit with no stack transfers.

If this is the root instance, the stack can be sent to STDOUT. Each
element on the stack will be pop'd and then sent as UTF-8 text (i.e.
stdout8). The user must request this behavior with a switch. -s?

    babel -s foo.bbl

----- exec/execs -----

    The exec operator executes a command through the OS's system call 
    method. In the case of Windows, this is CreateProcess and in *nix
    it is system(). See discussion of redirecting child process std I/O
    below.

    execs will "silently" exec the command, that is, it will not attempt
    to capture the process's STDOUT.

    exec expects a code block at TOS-1 to handle the process I/O:

        [( ["stdout"] lukha pr )] --This isn't right... what about stdin?
        ["c:\windows\dir.exe"]
    exec

    The execs operator requires only the name of the process:

    ["c:\windows\dir.exe"] execs

----- system() on Windows -----

    Creating a Child Process with Redirected Input and Output:
    http://msdn.microsoft.com/en-us/library/windows/desktop/ms682499%28v=vs.85%29.aspx
    
    More stuff:
    http://support.microsoft.com/default.aspx?scid=kb;en-us;190351

    The STARTUPINFO struct which must be passed to CreateProcess
    has a field for hStdInput and hStdOutput... this may enable
    "capturing" of STDOUT.

    http://msdn.microsoft.com/en-us/library/windows/desktop/ms682512%28v=vs.85%29.aspx

    Create some sort of thread manager with storage for the output 
    of the programs. Plan to dequeue and clean up this in a separate 
    thread regularly enough so that it doesn't get too big.

    For each third party app you want to 'host' create a thread. In 
    each thread create a process. Create named pipes for each of the 
    threads to capture the STDIN and STDOUT for each of the 
    processes (in your case you may only need the STDOut). 
    CreateProcess allows you to specify the specify the STARTUPINFO. 
    This startupInfo allows you to set hStdError, hStdOutput, and 
    hStdInput, which you can point to the named pipes, which should 
    be pointers on a structure in your object that manages all the 
    threads. In the threads, you (in a threadsafe way) update this 
    data.

    Then in your UI you can read or display this data independent 
    / asynchronous to the functioning of the actual third party 
    programs, whenver you display it you can clear the data off 
    the 'data collector' and move it to the UI manager since as 
    far as the command line program is concerned it's gone 
    anyway.

----- Mid-array References -----

    Include an "offset" field in the hash entry list for references.
    This field is used to "automatically" index into an array.

    Does this make sense?
        Only for leaf arrays...

----- Writeback -----

X Y [Z]   wr

    Exception if is_leaf(X) && is_inte(Y)

X Y [(Z)] wr

X Y&      wr


----- Stack operators -----

- down
    Moves "down" the stack
- nest
    Loads list on TOS as "current stack"
- up
    Returns up the stack from the last down/nest
- take
    Takes n items off the stack
- give
    Puts a list onto the stack
- depth
    Puts the stack length on TOS

----- Const/Variable Syntax -----

Enhance BPDL syntax to distinguish between const and variable labels.
Use a colon to define a variable. Use an equal-sign to define a const.

    main= (["Hello, world"] stdout)
    x: [x x]

There is still nothing preventing you from writing to const labels during
run-time (OOP folks will freak out; too bad for them) except you will 
probably blow up your program. Const definitions can be used by the 
assembler to eliminate unnecessary entries from the symbol table.

----- Ziggurat/Babel -----

At some point, fork the Babel project in two. The current development 
will be renamed "Ziggurat" and will be the "reference-standard" - a 
non-optimized implementation of Babel whose purpose is to be as 
perspicuous as possible.

The new fork will become the release candidate for Babel v1.0 and will 
be performance optimized. Test harnesses will be created to enable Babel
and Ziggurat to run in lock-step. Random Babel code will be generated and
executed on both models simultaneously for testing purposes.

Babel will implement a stack-based language in C:

    OpA(
    OpB(
    OpC(bvm_cache)))

Every operator will take a "bvm_cache" struct as input and produce the
same struct type as output. A "bvm_cache" is just a struct containing 
pointers to the most frequently accessed BVM data: code, stack, nil, etc.

Visually, execution order will be from the bottom to the top.

----- Slice/Paste -----

Extend slice and paste with 8-bit and 1-bit versions:

[0xdeadbeef] [4] [6] slice8 --> leaves [0xad] on TOS
[0xdeadbeef] [4] [16] slice1 --> leaves [0xbee] on TOS

[0xb] [0xbade] [1] [2] paste8 --> leaves [0xbabe] on TOS
[1] [0xcab] [8] [9] paste1 -> leaves [0xdab] on TOS

----- Logic -----

False = (is_leaf AND 0) OR (is_inte AND nil)
    Note that numeric 0 is the same as the empty-string in array-8 form

True = !False

and or not (logical operators)

& | ! (bitwise operators)

true -> syntactic sugar for [-1]
false -> syntactic sugar for [0]

----- Thoughts on hash-references -----

When an operator encounters hash-references on the stack, these should
be converted to the object they point to. Hash-references can chain so a hash-
reference will continue to be converted until it is resolved (detect circular
references?)

To turn something into a reference simply use the ref operator:

    [1 2] ref

The reference is just generated as a random number and inserted into the 
root namespace.

In general, you do not want to convert a reference back to pointer form as
this creates the possibility for memory leaks. If, however, you absolutely
must convert back, use deref:

    [1 2] ref deref (orig. pointer is now on TOS)

----- dup, zap, hash-references -----

a: [2 3]

a dup <--- how do we automatically memory-manage this?

We know when it is zapped, it is safe to free it but not everything
can be safely freed when zapped (we might try to free the same 
thing twice).

So, what will happen is dup will convert whatever is on TOS
to a hash-reference, if it is not already. Hashes will be 
enhanced to have an optional third meta-data for reference-
counting. If the value there is -1, the reference is not being
tracked. Otherwise, each new dup will increment the reference-
count and only when we zap on a ref-count of zero will the
associated object be freed.

NOTE: We may want to consider having an "rdup" operator to do this...
let the programmer decide whether he knows what he's doing or not.

----- Memory allocation -----

Note this applies to perf-optimized babel only.

We use lots of size 1 and size 2 arrays. The idea is to implement a 
dedicated free list for size-1 and size-2 arrays that is never itself
freed. To clean up after operating on a large, complex data-object,
simply use the gc routine mentioned below.

During a full-BVM restore, the interpreter will recognize this as an
opportunity to free the memory for the size-1 and size-2 lists and 
will do so.

----- Save/restore -----

Propose: New operators

Save just unloads the entire BVM and pushes it on rstack. Restore loads
the saved BVM and continues execution from there. Can be used for 
aggressive use of backtracking.

It might be nice to make the save/restore targetable... perhaps we only
need to save/restore a particular data-structure but we don't care about
the rest of the interpreter state because we're not touching it (have to
be careful for asynchronous stuff).

For example, during parsing, you want to speculatively fill out a parse-
tree and this tree can be really complex and undoing what has been done
up to this point can be complex. Saving a snapshot of the whole tree
at each decision-point provides a naive "brute-force" method of 
implementing back-tracking.

Proposed implementation: (ptr save) <--- saves whatever is pointed to
by pointer on rstack. Restore restores the object from rstack back to
the pointer. Must not free the location that holds the pointer in the 
intervening time.

Special case: (bvmroot save ... restore) this causes the entire BVM to be
wrapped up and saved on rstack. Once restore is called, the BVM on 
rstack is unloaded then the current BVM is blown away and the saved
BVM is set running again.

This also makes garbage collection very nice:

    gc: (save restore)

Note: this routine would have to exist in the BVM's parent and be 
invoked on behalf of the child BVM.

----- Hash-based BVM structure ------

Consider: Replace the current list-based BVM structure with hash-based or
nested-hash/namespace-based structure.

The basic idea here is that the BVM would be stored AS a hash.

Some nice things come out of this.

Loading into a particular namespace becomes "smooth" between hash-based data-
structures and BVMs... it's the same process.

We can adopt some nice conventions, as well.

For example:

/extern could contain the symbols that the loaded hash would like to link into
its parent (basically, get reference to parent's root hash).

/global could contain the symbols that the loaded hash would like to install
into its parent's hash, pointing into itself.

The loading BVM can, of course, decide whether or not to permit these actions.

Export/import of symbols? Imagine a BVM that, once loaded, wants copies of
some of the entries from its parent's hash table.

----- More hash-reference -----

Hash-reference on TOS when nil is encountered in code_list results in
a "tail call".

This will be how exceptions are implemented

Use the ret operator to get an unconditional return

Special hash-references
    When loading/unloading, not all info is saved/restored.
    For example, nil is not properly saved/restored.
    Need a way to say "point to the thing named 'x'"
    Also need a way to say "call this thing 'z'"
    Also need a way to say "place a copy of the thing named 'w' here"

----- Unix-inspired operators ------

pa (abbr.) means "path"

Namespace:
    ('hello' 'world') pa2str -> '<pwd>/hello/world' on TOS (pwd-relative)
    ('' 'hello' 'world') pa2str -> '/hello/world' on TOS (absolute)

    ['/hello/world'] str2pa -> ('' 'hello' 'world') on TOS
    ['hello/world'] str2pa -> (<pwd> 'hello' 'world') on TOS

    Modify hash operator to detect inte on TOS ... if it finds inte, it
    assumes this is a path and does a pa2str before hashing.

    foo cd -> sets pwd to <pwd>/foo
    /foo cd -> sets pwd to /foo
    .. cd -> sets pwd to parent of pwd
    ../bar cd -> sets pwd to the sibling of pwd, 'bar'

    /pwd -> puts the pwd on TOS

    /path    -> the relative-path search list. Contains '/babel/op' on boot

    '/hello/world' basename -> 'world' on TOS
    '/hello/world' dirname  -> '/hello' on TOS

    . dir -> puts a directory listing of pwd on TOS... e.g. ('foo' 'bar' 'baz' 'gimble')

    switchns -> changes the root namespace structure

    cpns/mvns/mkdir/rmns

List:
    cat
    cut
    join  -> like Perl's
        ('/' '' 'foo' 'bar') join -> '/foo/bar'
    split

    paste

    sort 
    uniq
    filter

Array:
    ls2ar
    ar2ls

    

Hash:
    ('foo' 1 'bar' 2) /my_hash ls2ha   --OR
    {'foo' 1 'bar' 2} /my_hash insns

    /my_hash ha2ls -> leaves ('foo' 1 'bar' 2) on TOS    

----- visible whitespace -----

    | (but not , ; or .)

    The vertical bar is a "visible whitespace" token... it is treated
    as logically equivalent to the ASCII 0x20 space.

    This permits you to do nice things with the formatting:

    ---------------------------------
    |       important_array:        |
    |    [ 5 4 1 2 7 3 7 4 0 1 ]    |
    ---------------------------------

    my_folding_quote:
        #\
        |   This   |
        |   is     |
        |   a      |
        |   folding|
        |   quote  |

    Note that visible whitespace does NOT apply within quotes:
    "Hello|world" will print exactly as it appears

    You can escape visible whitespace just like ASCII 0x20:

    my_weird\|name: [ 5 4 3 2 1 ]

----- floating-point -----

    Using the period as visible-whitespace raises the problem of the decimal-point:

        3.14 ftoa stdout
    
    However, Babel has no intrinsic floating-point support. It has p-nums but
    this is not the same:

        '3.14' p2dec stdout

    I'm not sure if Babel will have any native floating-point support (can always
    be added as a library).

----- non-alphanumeric operator aliases -----
    
    Think about syntactic catenation and prefix-freeness...

        Most important operators (guess)

        dup         *2
        cxr         @
        cond        ??
        sel         ?
        hash8       %
        size        #
        len         ##
        eval        ! (as in "Do it!")
        stdout      << (like cout)
        stdinln     >> (like cin)
        spit        <<<
        slurp       >>>
        swap        <->
        down        <-
        up          ->
        call        !! (as in "Do it!!")
        ciadd       +
        cisub       -
        cimul       *
        cidiv       /
        ciabs       ||        
        cieq        =
        cmp         ~=
        cilt        <
        cigt        >
        cile        <=
        cige        >=
        cand        &
        cor         | 
        cxor        ^
        cnot        ~  (hmmmm)
        show        $
        ci2dec      %d, etc.
        cat8        .
        and:            {0x1e6}
        &&:             {0x1e6}
        or:             {0x1e7}
        ||:             {0x1e7}
        not:            {0x1e8}
        ~~:             {0x1e8}

code:
    (   argv 0 @
        slurp8
        load *2
        [x] 0 paste

    --------------------------
    |  (    "next op: " <<
    |       
    |       [x] *2 *2
    |       cdr car car
    |
    |       *2 islf
    |       (   "push " <<
    |           bbl2str << )
    |       (   [opcode_map]
    |           <->
    |           @
    |           << )
    |       ? !
    |
    |       "\n> " <<
    |
    |       >> dec2ci bvmstep
    |       bbl2gv "snapshot.dot" spit8
    |
    |       "TOS: " <<
    |       cdr cdr cdr car car car
    |       bbl2str << "\n" << )
    [-1]
    times )


----- each with uptr -----

    The regular each operator makes a copy of each entry in the
    array and places this copy on TOS. But lets say you want to
    increment the value of each entry of a leaf array. We should
    be able to say something like:

    ---
        (1 cuadd)
        [1 2 3 4 5]
    eachar

    The way we'll make this work is if you have a uptr to an array:
    
        my_array: [1 2 3 4 5]

        1.newup
        {'my_uptr'}.nil.insns

        ---
            my_array
            my_uptr
            0
        paste

        ---
            (1 cuadd)
            my_uptr
        eachar

----- hash-quoting -----
    
    If you use curly-braces, this means "create a hash with the following 
    key-value pairs":

    my_hash: {"key" value}

    This requires an even number of elements in a hash list. But what
    if there were just one entry?:

    my_hash: {"key"}

    Babel will take this as a "clever" sign that you just want the
    single entry to be HASHED and its hash substituted in place. This
    works for strings or any other Babel data structure:

    my_hash: {1} -- returns the hash of the mword 0x00000001

    my_hash: {[1 2 3 4 5]} -- returns the hash of all these mwords
    -- This becmoes problematic with non-leaf arrays...

----- s-expr parsing -----

    Just like the namespaces will be broken up and parsed into a list,
    so it would be nice to do the same with all paren-like tokens...

    () [] {}

    These get automatically parsed

----- Babel extension hooks -----

    Instead of implementing any/all, Babel will provide a SET of hooks
    for extending the built-in operator set.

    - Operator extension
        This will hook into the switch statement in bvm_interp.h...
        basically, just a dynamic jump table.

    - Destructor extension
        This will permit the objects created on the stack by extended 
        operators to be automatically destroyed. The corresponding 
        destructor will be called whenever the object is removed
        from the stack (we may need a non-freeing zap).

    - Selector extension
        This will permit extension of the nil-detection at the end
        of a code-list - it will also allow other forms of jump-table
        behavior... basically, the equivalent of putting a "continue"
        or even a "return" in the bvm_interp.h switch statement instead 
        of a "break". Also, interaction with rstack is permitted.


----- Idiomatic Operators

Doing a fold with eachls:
    --
        0
        ( cuadd )
        ( 1 2 3 4 5 )
    eachls

Doing a fold with unstack:
    (1 2 3 4 5)
    unstack
    --
        (cuadd)
        4
    times

Doing a C-style switch with cond:
    --
        (([x] 0 gt)
            ("positive" say)
        ( [x] 0 lt)
            ("negative" say)
        ( [x] 0 eq)
            ("zero" say))
    cond

Doing a sequence of conditionals:
    -- THIS DOES NOT WORK!!!:
        ([x] swap eval)
        (( 0 gt "positive" say)
        (  0 lt "negative" say)
        (  0 eq "zero"     say))
    eachls


Filtering with grep:
    --
        ( 2 cugt )
        ( 1 2 3 4 5 )
    grep

    Leaves ( 3 4 5 ) on the stack

Cartesian product:
    --
        ((1 2 3 )
        ( 4 5 6 ))
    cart

    TOS: (((1 4) (1 5) (1 6)) ((2 4) (2 5) (2 6)) ((3 4) (3 5) (3 6)))
    
    Works for all dimensions


    TOS: ((1 5 10) (2 6 11) (3 7 12) (4 8 13) (nil 9 13) (nil nil 15))

Zip-each?:
cart-each?: (can't we easily do these with existing stuff?)
sort


----- variables ------

babel:
    env:
        argv: [nil]
        argc: [0]
        path: [nil]
        home: [nil]
        pwd:  [nil]
        user: [nil]
    asm:
        fnord: {0x100}
        etc:
    disasm:
        [ "err" "cushl" "rsvd" "cushr" ... ]
    bvm:
        steps: [0]

--------------------------
arcut
link (ostruct)

--> TODO: Operator naming convention cleanup... need
to do this at some point.

--> TODO: Fix loop, next, last
--> TODO: Bug in nested ret's due to nil

----- spanning tree -----

span
    this operator constructs a spanning tree across a
    bstruct. the pointers into each array in the bstruct
    are unrestricted pointers so they block traversal,
    permitting the spanning tree to be traversed while
    maintaining its distinction from the bstruct it
    spans.

----- some new bstruct operators ----- 

comp
	does a shallow compare
	think abt interior vs. non-interior
diff
	L R| --> (L n !R) (!L n R) (L n R)|

	To test for sameness, check if TOS-1 and TOS-2 are both 
	nil or both not nil.

    The results created by diff use uptrs to point into
    the originals

----- Re-organized array and list operators ------

list-read operators:
    car
    cdr
    cxr     (these are the same as before)

DONT NEED A TRAV OPERATOR:
    my_bstruct
        (cxr)
        (1 0 4 9 8)
    each

list-write operators:
    wrcar
    wrcdr
    wrcxr (pretty obvious, these will replace "w")
    wrcaar
    wrcadr
    wrcaxr (these will replace "save", they do a "staggered write")

array operators:
    filter
        filters the elements of an array according to a list of select values
    cut
        cuts an array
    slice
        selects a slice of an array
    paste
        currently what w does
    move
        an in-array memmove, will also have a move8
    carpaste
        like wrcaxr except can paste an entire array into another

There seems to be a larger conceptual design issue here between 
in-place/destructive operations and on-the-stack/copy operations. Need to
think about this some more and try to build more conceptual clarity into 
the operators.

Overwrite is an issue wherever you are trying to UPDATE STATE. Because
Babel is not trying to be "conceptually pure" or "functional", most 
operators default to being destructive. If you don't want to destroy
something, just dup it and then use the operator on the dup'd copy.

However, carpaste and the wrcaar, wrcadr and wrcaxr operators work around
the limitation of "pulling" each level of a bstruct onto the stack before 
you operate on it. The primitive operators (arithmetic, logic, etc.) only
operate on stack copies of values, not on the values themselves in memory.

-----------------

Idea: pwd instead of parameter lists for functions?

e.g.:

    ( '/myvar' [foo] call )

foo:
    (pwdset
    ... do whatever
    ret)

-----------------

----- Unrestricted pointers -----

    An unrestricted pointer or uptr is a pointer stored in an array 
    of size 1 but which has an s-field of 0. Traversing operators 
    do not traverse through C-style pointers.

    A cptr can point at any leaf or interior array. There are two 
    types of cptr - safe and unsafe. A safe cptr consists of a 
    "base and offset" pair - the base is restricted to only point
    at the first element of an array. Unlike the pointers in an 
    interior array, an unsafe irregular pointer can point at any 
    valid location in an array. This permits "C-style" pointer 
    arithmetic and de-referencing. The functional behavior of
    safe and unsafe irregular pointers is exactly the same and
    both have the same internal format so that code which was
    originally written with unsafe cptrs can be executed in a 
    "safe mode" by the interpreter without code modification.

    These properties of irregular pointers permit the following
    usage models:

        - Better-performance array access
        - Fencing of data-structures that contain pointers so 
        that deep-copy or other traversing operators will only
        copy the portion of interest.
        - Safe execution of code containing unsafe irregular 
        pointers though at a performance cost

    Use an array label to create an irregular pointer or use the
    mkcptr operator. Use deref to dereference it.

    mksptr and sderef are the safe versions

----- Conditional -----

Cond short-circuits on the first matching condition, that is,
it exits the structure. Switch only exits the structure if
the "last" keyword is used. This permits C-style fall-through
behavior. Order matters.

       ((cond-a)
            (action-a)
        (cond-b)
            (action-b)
        ...
    cond)

       ((cond-a)
            (action-a)
        (cond-b)
            (action-b)
        ...
    switch)

----- Loops -----

echoer:
        ((  "> "    stdout 
            stdinln stdout 
            "\n"    stdout )
    loop)

print_10x:
        (( "Hello, world\n" stdout )
    10 times)

decrementer:
        (( [i] 1 cusub )
    ([i] 0 cugt) while)

sum:
        (0
        ( cuadd )
    [1 2 3 4 5] each)

sumls:
        (0
        ( cuadd )
    (1 2 3 4 5) eachls)

----- Structs -----

    You can create a "struct" in Babel using either the structls
    or the structar operators.

    The structls operator takes a list and converts it into a hash
    containing code that will access the particular element of the
    list.

        (1 (2 3))
        ('a' ('b' 'c')) structls
        'c' luha 
        -- [cdr car cdr] is now on the stack
        eval 
        -- 3 is now on the stack

    The structar operator works similarly:

        [ [1] [ 2 3 ] ]
        [ ['a'] ['b' 'c'] ] structar
        'c' luha
        -- [?] is now on the stack
        eval 
        -- 3 is now on the stack


----- Labels -----

    There are two kinds of labels - list labels and array labels.

    A list label can be placed anywhere inside a list:

        (1 2 lslabel: 3)

    Now, the label can be used to refer to the last element of the list:

        (lslabel car 1 add)

    An array label creates an irregular pointer:

        [1 2 arlabel: 3]

    To use it:

        (arlabel deref car 1 add)

    Note that, for the sake of consistency, an irregular pointer is formed
    even if the label points to the first element of an array:

        [arlabel: 1 2 3]

        (arlabel deref car 1 add)

----- In-place expansion -----

    --- Lists

    Assume you label some code:

        add3: 3 add  -- Parens are automatically implied

    Now, we have to differentiate between "control transfer" to the labeled
    code versus inline placement of the code. To control transfer, do the
    following:

        4 add3 call

    This transfers execution control to code. Result is '7' on the stack.

    If, instead, you wanted the code to be inlined, interpolate it. To 
    EXPAND a list into another list, use the {} operator:

        4 {add3}

    But this:

        4 *add3

    ... is equivalent to:

        4 (3 add)

    ... which is not what is desired in this case.

    This leads to some interesting conclusions.... 

        {(4)} 

    ... is equivalent to:

        4

    --- Arrays

    Let's say we have an array:

        my_arr: [1 2 3]

    Now, we want to sum it:

        my_arr sum  -- pushes a pointer to my_arr on the stack

    But let's say we wanted to expand my_arr into another array, then sum that:

        my_other_arr: [{my_arr} 4]

    ... equivalent to:

        my_other_arr: [1 2 3 4]

    ... also equivalent to:

        my_other_arr: [*my_arr 4]

    For arrays, * and {} are equivalent.


----- Hash/obj/namespace constructors -----

    - Hash
        A hash table allows structured association of a hashed string with a pointer

    - Obj
        An obj consists of a hash-table and an associated Babel structure:

        ( hash_table . babel_struct )

        The hash-table contains pointers *exclusively* into the associated Babel structure.

    - Namespace
        A namespace is a special case of an obj. It is an obj with certain properties that
        make it behave like namespace of the familiar Unix filesystem.

        1. The hash-table must contain the hash of '/' and this must point to the base of
        the associated Babel-structure.

        2. Every entry in the hash-table must be the suffix of an existing entry cat'd with
        '/' except for entries that are a suffix of (1)

        3. Every entry in the Babel structure must be pointed to by one entry in the 
        hash-table

        4. Every entry in the Babel structure must have as its parent the Babel structure 
        entry whose corresponding entry in the hash table is its longest prefix

----- Obj loading -----

    'name0' hash dup [src_obj_file] objlu [dest_obj_file] subst

    Step 1) Look up the pointer by (hash of) name in the source obj file hash-table
    Step 2) Substitute any occurence of the hash of the name in the dest obj file with the
            pointer which was looked up in Step 1

----- API/Commandline -----

    Babel should expose itself as an API so it can be built
    into other projects.

    Specifically, it should be possible to pass in a .bbl
    or .bob and have it work correctly. The use of global
    variables might be a problem.

----- Babel arithmetic -----

    Want to support arbitrary-precision

    Would like to have p-adic support

    Addition and subtraction easy to implement

    Regular multiplication:
    http://en.wikipedia.org/wiki/Multiplication_algorithm#Lattice_multiplication

    Division (inversion): see 2adic.c

    Notation:
        http://mathforum.org/dr.math/faq/faq.typing.math.html
        http://www.karlscalculus.org/email.html

    Babel arithmetic will consist of the following basic operations:

        + - * / exp ln abs mod atan sin? sinh? etc.? pi? ln2?

    A Babel numeric value is called a "p-number" or pnum. This is a reference to
    p-adics. Specifically, Babel implements 2-adic arithmetic and maintains all
    numbers internally as 2-adic integers. You can evaluate a numerical expression
    to calculate a truncated 2-adic number as a result. If this result is stored
    and re-used, it will be treated again as a 2-adic integer. If you require
    arbitrary precision in your calculations, do not store intermediate truncated
    2-adic numbers (simply construct a larger function).

    Babel's system of arbitrary precision is explained below:

    ----- Big idea

    Similar to Michael Stoll's CREALs for Lisp, Babel can implement arbitrary 
    precision arithmetic by defining numbers in terms of functions to compute
    them.

    Let's say you want to use the value 1/sqrt(5) in a calculation. First,
    define it:

    inv_sqrt5: (5 sqrt inv)

    To calculate it to 10 words of precision (320 bits):

        10          -- precision
        inv_sqrt5
        peval       -- pnum evaluation

    How precision is managed:

    - For addition and subtraction, we need n bits of precision
    from each operand to produce an n-bit result

    - The same for multiplication - the key is to work on a 
    diagonal of the multiplication lattice. That is, lattice 
    multiplication places the result along the bottom and left
    edges of the lattice... this will lead to incorrect results
    for p-adic multiplication... the correct approach is to
    only take results along the bottom edge of the lattice and
    expand the lattice until it is large enough to accomodate
    a particular operand size.

    In short, an n-bit result requires two n-bit operands as
    in the case of addition and subtraction.

    This conclusion was reached by intuition and therefore, 
    may be mistaken. Will need help from more a mathematically
    knowledgeable individual to check this.

----- Arrays -----

    --- arnth
    
    Returns arlen-1

    --- Arrays of width < mword

    Babel uses a convention for determining the length of arrays
    which have a width less than the mword size.

    Array width must be 2^n bytes, n>=0.

    What is the length of an array of 10 bytes?

    The mword length is 3 since 3 mwords will be used to store the
    10 bytes. But naive multiplication of mword-size would result
    in an incorrect array length of 12. Hence, Babel stores an
    alignment word at the end of the array.

    In 32-bit Babel, the alignment word is one of:

        0xffffffff      byte-length % 4 = 0
        0xffffff00      byte-length % 4 = 1
        0xffff0000      byte-length % 4 = 2
        0xff000000      byte-length % 4 = 3

    arlen8 or arlen16 (or arlen32 in 64-bit Babel) will return the 
    correct array length for the given array width.

    Note that naive use of arlen on non-mword arrays will likely 
    result in program bugs.

    ----- arcat*

    arcat8/arcat16/arcat32

    ----- v*/p*

    v8/v16/v32
    p8/p16/p32
    vw8/vw16/vw32
    pw8/pw16/pw32

----- Built-in Functions -----

    NOTE: 
        Get rid of ls2ar... same as bons
        Get rid of shat... does not need to be a built-in

    ----- LIST -----

    cons
        cdr car| -> (car . cdr)
    bons
        "Babel cons"
        conses an entire list into an array of pointers
    car
    cdr
    ls2ar
    lslen
    isnil
    isls
    append
    flatten
    lsrev

        ls -> list
        ar -> array
        pt -> a pointer
        va -> a value
        ha -> hash
        lf -> leaf (value array)
        in -> interior (pointer array)

    ----- ARRAY -----

    newin
    newlf
    in2lf
    s
    arlen
    islf
    isinte

    mu
    nva
    npt
    nlf
    nin
        mu = nva + npt + nlf + nin

    ar2ls
        can be used on either but meant for leafs
        [1 2 3] -> (1 2 3)
    arser
        
    c
    shat
        "shatter" - the inte version of ar2ls
        [a b c d] -> (a . (b . (c . d)))


    ----- FILE -----

    open (bin default)
    close

    mem-mapped files?

    ----- MEMORY -----

    new
    del

    ----- BVM -----

    bvmptr
    mkbvm
    bvmgo
    bvmquit
    bvmkill

    ----- MISC -----

    halt
    fnord

    ----- STACK -----

    push
    pop
    stack
    unstack

    zap
    dup
    i
    dip
    zap
    dup

    ----- MOVES -----

    cp
    dcp (deep copy)
    mv

    ----- CONDITIONAL -----

    sel
    popif
    fncall
    fnret

    ----- PSEUDO -----

    dump

    ----- ARITH/LOGIC/COMP -----

    see opcode_map.txt

----- Irregular Arrays -----

    An array with s-field = 0 is an "irregular array".
    There are no rules about what can be in an irregular array.
    Programs that use irregular arrays cannot be saved/restored.
    Irregular arrays can be used for increased perf by pointing in
    to the middle of an array (prohibited for interior arrays)
    and also to "fence" deep-copy of objects that contain pointers
    to other objects that you do not want to be included in deep-
    copy.

----- Debugger -----

    On startup, Babel constructs its own BVM (the "shell") before 
    launching the user's BVM. The user's BVM is invoked by the wrapper 
    BVM with the bvmgo operator. The user BVM can use bvmbrk to break 
    out of the current BVM into the next higher BVM. In order to 
    facilitate debug on nested BVM's, there are two special-purpose 
    operators - bvmdb and bvmrsm.

    bvmdb breaks from the current BVM all the way to the shell BVM.
    bvmrsm re-enters the BVM which was broken out of by bvmdb

    Tracing will cause the debugger to decode the operator to its
    plain-text representation as well as depict changes to the stack
    and stack operands. Rstack?

----- Eval -----

    Babel has four forms of eval.

    ----- eval

        Recursive Babel evaluation.

    ----- Babel macro eval

        maceval

    If you want to eval a macro without flattening it (substituting its
    parameters), use the maceval operator. Every time an unresolved symbol
    is encountered in the macro, it is looked up in the symbol-table (at
    run-time). While this is a slower form of execution, it can provide
    significantly increased modularity and may be suitable as a high-level
    interface wrapper around regular code.

    ----- areval

    Requires an array containing code to be evaluated on TOS

        [2 3 add] 
        arval

    ----- lispeval

    Invokes operators in prefix-order:

        2 3 4 mul cuadd

    becomes:

        (cuadd 2 (mul 3 4)) lispeval

    lispeval will recursively call itself every time a list is
    pushed onto the stack. It will "stuff" the first element of
    the list for future execution. See the "PrefixAlgorithm.doc"
    for more info.

----- Exec -----

    Windows:
    http://msdn.microsoft.com/en-us/library/ms682425%28v=VS.85%29.aspx

    Linux:
    http://www.yolinux.com/TUTORIALS/ForkExecProcesses.html
        system()

    Windows CreateProcess() == Linux fork()/exec()

    For parallel processing, we will use memory-mapped files for
    data-sharing.

    If you want to nest BVMs in the same OS process, just use bvmexec

    If you want to launch a BVM in its own OS process (parallel execution)
    use the exec operator to invoke another instance of babel and 
    provide the current .bbl file and shared memory file-name to babel.

    If you want a *nix-style fork of your Babel code (but the interpreter
    itself!), use the bvmfork operator.

    In general, the exec operator acts like *nix fork/exec or Win equiv.

----- File I/O -----

    Babel exposes the C file I/O functions as Babel operators. However,
    the C std library is pretty old and best practice has changed a 
    bit in the meantime. Babel provides some streamlined operators for
    file I/O. 

    -- slurp/spit/journal

    For most small files where it's not a waste to read in the entire
    file to memory, you can use the slurp/spit operators.

        "/home/test.txt" slurp

    This reads in the entire file /home/test.txt and leaves a leaf
    array containing the file on TOS. slurp automatically closes the 
    file after reading it in.

    slurp operates in bin mode only. Use the string manipulation
    operators and the /babel/newline environment variable to process
    the file once it has been read.

    (We should probably have a configurable slurp file-size limit
    to prevent accidental attempts at slurping huge files).

    If the file does not exist, slurp will raise an exception.

    To write a file at once to disk (overwrite, not append), use spit:

        [ 0 1 2 3 4 5 6 7 8 9 ] "/home/output.bin" spit

    This writes 10 mwords with values 0-9 to the file /home/output.bin
    replacing whatever was in it. Spit automatically closes a file
    once it has finished writing to it.

    To spit in append-mode, use the journal operator:

        "Done... Signing out.\n" "/home/logfile" journal

    If the file did not exist, spit and journal will create it (no 
    indication is given).

    journal DOES NOT automatically close a file. To ensure a file
    is closed, use the clfile operator.

    If something goes wrong, spit/journal will raise an exception.

    If you do not want this behavior, you can always use the old-
    fashioned C file I/O operators.

    -- *file

    For larger files, you will want to use the *file operators. The *file
    operators implement a memory-mapped file interface.

    To read from a file, specify a leaf array to store the file into, the 
    filename and the _BYTE OFFSET_ into the file you want.

        1000 newlf              -- Creates a leaf array of 1000 mwords
        "/home/bigfile.mpg"
        123985
        rdfile

    The above example reads MWORD_SIZE*1000 bytes from /home/bigfile.mpg
    into the leaf array, starting at byte offset 123985 in the file.

    Only the filename and offset will be cleared off the stack after
    rdfile finishes, so the leaf array is still accessible on the 
    stack.

    rdfile will create the file descriptor if it did not already exist.

    Note that the filename, the size of the destination leaf array AND 
    the offset all affect whether rdfile creates a new file descriptor.

    If something goes wrong, rdfile will raise an exception.

    To close all descriptors associated with a particular file, use
    the clfile operator:

        "/home/bigfile.mpg"
        clfile

    This DOES NOT write back any changes.

    To write to a file:

        my_leaf_array
        "/home/bigfile.mpg"
        123985
        wrfile

    Like rdfile, wrfile will create a new descriptor if one did not
    already exist.

    Because it is possible to get "descriptor leaks" if you mistakenly
    use the wrong size array or the wrong offset, you can use the 
    cntfile operator to find the number of descriptors for a particular
    file:

        ( fnord )
        ( zap "Descriptor leak detected\n" stderr die )
        "/home/bigfile.mpg"
        cntfile
        1
        gt
        zapif
        eval


    In windows, 

        http://msdn.microsoft.com/en-us/library/aa366556%28v=VS.85%29.aspx

    In Linux,

        http://en.wikipedia.org/wiki/Mmap
        http://beej.us/guide/bgipc/output/html/multipage/mmap.html


----- Flow control -----

    Flow-control in Babel is the sel operator:

        ("a is greater than or equal to b" pr)
        ("a is less than b" pr)
        a b lt
        sel
        eval

    This is how sel operates:

    A B  (0 or nil)| -> A|
    A B !(0 or nil)| -> B|

    Basically, you read from the bottom up.

    You can nest sel's:

        (
            ("a is greater than b" pr)
            ("a is equal to b" pr)
            a b eq
            sel
            eval
        )
        ("a is greater than b" pr)
        a b gt
        sel
        eval

----- Functions, macros and lambdas -----

    Functions

        To create something that behaves like you would expect a function to
        behave, you simply need to use temporary variable stacks:

            fac:
                n push  -- TOS gets pushed on the stack referenced by '/fac/n'
                (n car dup 1 sub fac mul)
                (zap 1)
                n car 0 eq
                if
                eval
                n pop   -- Clean up after yourself, otherwise memory leak

                help:
                    #-
                        This is a block quoted help section

        Instead of having a single stack, each "automatic variable" is
        actually its own stack. This is purely conventional, you need not 
        implement function calls this way, I just find it to be the most 
        elegant.

    Macros

        To implement and use a macro:

            add2: 2 add
            3 add2 eval -- The stack now has 5 on it

    Lambdas

        To create something that behaves like a lambda:

            op2: (2) swap cons eval

    count: {
        from     cp     -- since we are in an anonymous lexical context, multiple calls to 
        to       cp     -- counter will create unique variables each time, avoiding namespace collisions
        stride   cp
        to count cp
        ((from stride cp)
        (zap count stride add)
        to count gt
        if
        eval)
    }


----- Inline C -----

    see tcc/libtcc.c


----- Interpolation -----

    Babel has four types of interpolation
        
        - string interpolation
        - macro interpolation
        - general interpolation (Markov algorithm)

    ----- String Interpolation

    strint permits you to perform complex substitutions on a
    Babel character list.

        adj
        'interpolated'
        str2ls
    assign

        "This string is {adj}"
        str2ls
    strint

    ----- Babel macro interpolation

        macint

    A Babel macro is a Babel data-structure that has unresolved symbols in it.

    There are three types of unresolved symbols:

        - "babel_unresolved_inte" 
        - "babel_expanding_unresolved_inte"
        - "babel_unresolved_leaf"

    The hash of the unresolved symbol type is stored at the point at which
    the object is to be inserted, followed by the hash of the symbol name
    to be substituted. The macro interpolator looks up the hash in the symbol 
    table at macro-creation-time and substitutes the entry in the symbol 
    table for the hashes.

    The macint operator is also how Babel object files are resolved. An object
    file is just a macro which has been written to file.

    -------------------

    interpol

        x y| -> z|

            - x     the list on which to perform the interpolations
            - y     a list of substitutions
            - z     the interpololated list

        TOS must consist of a list of (match sub) pairs. match is a 
        pointer to a list which will be provided to the pegpar operator. 
        The match generated by pegpar will then be passed to sub. 
        Whatever sub returns will be substituted into the string. The 
        (match sub) list is ordered; the first item has highest precedence, 
        the second has next-highest precedence and so on. It is possible 
        to implement a Markov algorithm with interpol.


----- Lists -----


    Functions:

    unquote
        takes a list on car of stack
        concats the list with the stack itself

    eval
        takes a list on car of TOS
        appends eval-list to the given list
            and begins evaluating from car

    name
        takes a string on car of stack
        inserts entry into the symbol table pointing
            to cdar of stack

        Potential issue:
            0 'x' name zap x -- What happens?

    if
        if car is true
            pops stack 
        else
            pops stack twice

    symbol-name:
        when a symbol-name is encountered in the code, its car becomes
        the current focus and eval-list is appended to it

    tos -- Top Of Stack
        This symbol can be used to directly refer to the stack itself
        e.g.
        tos cdr  -- Returns the second item on the stack

    sum: -- I'm pretty sure this is correct:
        'x' arg
        (sum x car add) -- else
        (zap x car)
        x cdr isnil?
        if
        eval
        delargs

    PROBLEMS:
        destructiveness... constant copying???


    Lisp-style functions:

    car
        returns the car of the list on TOS (NOT CORRECT/CONSISTENT)

    cdr
        returns the cdr of the list on TOS

    cxr0 - cxr15
        an enumeration of caaaar through cddddr where 'a'->0 and 'd'->1

    append
        appends the list at car and the list at cdar on the stack
        (1 2 3) (4 5 6) append
            -- Leaves (1 2 3 4 5 6) on stack

    cons
        takes two lists on the stack
        creates a new list which has the first list as its car and the second list as its cdr
            (1 2) (3 4) cons -- Leaves ((1 2) 3 4) on the stack

    quote
        In Babel, you don't need an explicit quote operator, simply place the thing you want to quote in another
        set of parentheses:

        (1 2 3 4)
        -- Quoted:
        ((1 2 3 4))

        -- Seems not fully thought out...... FIXME

    eq
        compares two atoms for equality (identity) and returns 'true' if the atoms are the same, NIL if they are different.

    atom
         of an S-expression is 'true' if the S-expression is an atom, and NIL otherwise.

    null
        of an S-expression is 'true' if the S-expression is the empty list (that is, NIL), and NIL otherwise.



    NEW:

    cp
        DEEP copies the list pointed by TOS.car to the location pointed to by TOS.cdar

    mv
        Unlinks and moves a stack from one place to another


    ##### EXTENDING LISP/JOY

    -- SWITCH
    -- The "list stack" is really just a pointer to a particular sub-tree. This pointer
    -- can be moved anywhere with the 'switch' operator.

    my_new_stack: ()

    (my_new_stack) switch

    -- To get back where you started from:

    tos 'return' name my_new_stack switch

    -- Or, if you wanted to use an anonymous reference to create a new stack:

    () car switch

    -- This creates a "nested stack" as it were
    -- To get back:

    ... return switch

    -- GO
    -- The same is also true of the "code stack"
    -- To go to a completely new sub-tree, use the go operator

    my_code: do this do that etc.

    (my_code) go


    -- RMCAR
    -- unlink car
    -- You can unlink a sub-tree:

    (1 2 my_sub_tree: (3 4) 5) my_sub_tree rmcar

    -- Result:

    (1 2 5)

    -- rmcdr
    -- inverse of above:

    (1 2 my_sub_tree: (3 4) 5) (my_sub_tree) rmcdr

    -- Result:

    (1 2)

    NOTE: Unlinking does not delete. You have to delete the symbol
    reference to completely delete the sub-tree:

    (1 2 my_sub_tree: (3 4) 5) (my_sub_tree) rmcar (my_sub_tree) delsym


----- Loading -----

    - Traverse the tree
        - If interior node, increment by base pointer value
        - Else, do not change


    3 imm       -> 0x0000000d
    4 list      -> 0x00000010
    2           -> 0x00000002
    6 imm       -> 0x00000019
    7 list      -> 0x0000001c
    3           -> 0x00000003
    9 imm       -> 0x00000025
    nil         -> 0x0000002a
    add (17)    -> 0x00000022
    3           -> 0x00000003

    ^^^Sample object file

    ##### Virtual machine types

    Babel has three types of virtual machine.
        - List absolute
        - List relative
        - Vector absolute

    A binary loaded from file will be in list-relative
    format, so the list-absolute interpreter invokes
    an instance of the list-relative interpreter.

    ##### Loading:

        - Loading binary from file (or memory)
            Binary Babel files are stored in list relative form
            No loading is required to execute list-relative in
                the interpreter
            However, the list-relative interpreter is slow since
                every instruction, reference, pointer and so on
                must be fully offset

        - Loading list absolute
            The list-relative interpreter can still use the list-
                absolute operators to construct references, copy 
                lists and so on.

                e.g.




        - Loading

    tos
    tocs
    max_malloc

    Vector Loading:

    Vector loading is a run-time process

    A loadable vector 

----- Memory Management -----

    -- Memory management

    Memory management in Babel is hierarchical.

    This means that when you delete a memory region, all sub-regions will
    also be recursively deleted.

    To implement this, Babel keeps track of where you initially store the
    pointer returned from a call to new. The memory region in which you
    initially store the pointer becomes the parent region of the newly-
    created memory region. Deleting the parent will recursively delete
    this and all sub-regions.

    In the hidden segment in the BVM header, there is an entry for the
    mem_tree. Each entry in the mem_tree has the following form:

    ( begin end descend )

    For example, if you call new three times while in the main obj page,
    the mem_tree will look like this:

    ( (begin0 end0 descend0) (begin1 end1 descend1) (begin2 end2 descend2) )

    Any of the descend* may point to a list with this same form.

    When new is called, a search is performed on the mem_tree to find which
    region the new pointer will be stored in. The new memory region will
    then be appended to the descend list of the parent memory region.

    Similarly, when del is called, a search is performed to find what memory
    region the pointer that was given to del resides in (you don't have to
    do a delete on the BASE of the memory region, as in C/C++). This region
    and all its descendants (if any) are recursively deleted.

    We could add a fast_new and fast_del for when the user knows exactly
    which region in the mem_tree is affected.

    Unlike C/C++, it is very important where you store the pointer from
    a call to new. This determines the lifetime of the memory region - its
    lifetime is less than or equal to the lifetime of all its ancestors.

    Structuring memory allocation in this way makes it much simpler to free
    memory constructed from many new's in a local context. Simply freeing
    the parent context will free all memory alloc'd while in that local
    context.

    ----- balloc/bfree

    In addition to new/delete, there is also a more manual interface. If
    you want to manage when you delete your memory, use a call to balloc.
    This is just a wrapper around malloc that keeps count of memory usage
    for containerization.

    ----- Namespaces

    Namespaces are also hierarchical and it is not an accident that the 
    hierarchical structure of memory in Babel corresponds with the namespace
    hierarchy. If you delete a namespace, the memory of all child namespaces
    is recursively freed using the hierarchical mem_tree.

    Memory management of namespaces is automatic. In other words, the 
    memory management of named objects is automatic. new/del is semi-automatic
    in that del will automatically remove all descendants. balloc is fully
    manual memory management.

----- Namespaces -----

    foo:
        pwd     -- puts ('' 'foo') on TOS
        last    -- gets the last element of a list
        pr      -- prints 'foo' to STDOUT

        '/' ('' 'foo') '/' join cat

    --- Making a namespace:
        
        #-
            foo:
                bar:
                    (17 32 10)
        mkns -- makes a namespace structure from the above text

----- Core Operators -----

    Core Operators

        Conventions

        - A specific operator will expect a specific number and type of operands (no hidden polymorphism)
        - Machine word operators are denoted with a c- prefix, i.e. cuadd -> "C-style unsigned add"

        a b sub   -- means a - b

    Flow-control:
        if
            (0 A B) -> (B)
            (1 A B) -> (A B)

    Joy:
        swap
            (A B) -> (B A)
        zap
            (A B) -> (B)
        dup
            (A) -> (A A)
        zap
            (A) -> ()
        eval
            ((A) B) -> code:(A)
        switch
            Switches TOS to point to the list referenced at current TOS
        go
            Switches TOCS to point to the list referenced at TOS
        tos
            Puts a reference to current TOS on the stack
        tocs
            Puts a reference to current TOCS on the stack

    Stack:
        push
            Pushes onto the stack referenced at TOS
        pop
            Pops from the stack referenced at TOS

    Comparison:
        gt      Obvious
        lt
        eq
        ge
        le
        ne

    Arithmetic:
        add     Obvious
        sub
        mul
        div

    I/O:
        pr
        query

    Memory:
        cp
            (A B) -> Recursively copies from reference A to reference B
        mv
            (A B)

    Lists:
        car 
        cdr 
        cons
        isnil
        append
            (A B) -> Appends list A to list B
        atom ?
        rmcar
        rmcdr

    Symbol table:
        insym
            Inserts a symbol into the symbol table
        rmsym
            Removes a symbol from the symbol table
        exsym
            Tests for existence of a symbol in the symbol table
        defsym
            Tests for definedness of a symbol in the symbol table
        pwd
            Puts the present working directory on the stack

    Vectors:
        mkvec
            Makes a vector given a few parameters
        th
            Returns the nth element of a vector
        ijth
            For multi-dim vectors
        joinvec
            Joins two vectors together
        vcp?
            Copies a certain number of elements from one vector
            to another of the same width
        lenv
            Returns the vector's length (how measured?)
        width
            Returns the vector's width
        dims
            Returns the dimension list of a vector

    References:
        deref
            Dereferences whatever's at TOS
                Equivalent to 'car' for list-references
        s2href
            Converts a symbol to a hash-reference
        s2ref
            Converts a symbol to a raw reference
        h2ref
            Converts a hash-reference to a raw-reference

    Strings:
        cat

----- Stack -----

    -- stack

    The stack consists of a spine of cons cells that are memory-managed
    by the interpreter. Hanging off the spine are whatever the user is
    pushing and popping.

    The built-in functions (such as add, sub, mul, div, etc.) that return
    a result on the stack allocate memory for the result through the
    interpreter. If you want a result to be persistent, you must copy it
    out of the stack and store it elsewhere. As soon as the value is
    popped from the stack, it ceases to exist. For example, let's say you
    have two lists, A and B and you cons them:

    A B cons

    You must copy the result somewhere if you want it to survive past
    a pop. 

    A B cons pop -- The cons'd list is gone

    Correct way:

    A B cons mylist cp pop

    Now, A COPY OF the cons of A and B is stored in mylist. When you pop,
    the original cons gets freed.

    -- rstack

    Used for pushing return pointers by the call/ret operators

    -- dup/dig swap/rollup

    Babel provides two stack-manipulation operators to implement the 
    functionality of Joy's many stack-manipulation operators. Babel's
    operators are more minimal and provide a wider functionality.

    The two operators are:

        - perm8
        - dup8

    Both operate on the same principle except that perm8 does not 
    increase the size of the stack (like swap/rollup) where dup8
    does (as dup does).

    perm8 takes a single numerical operand on TOS. The argument
    is 32-bits (or the lowest 32-bits on 64-bit machines) divided
    into 8 4-bit fields. Each field is numbered F0-F7. The least 
    significant 4 bits of the 32-bit operand is F0. Each field 
    can have one of nine values, 0x0-0x7 or 0xf. For each field n
    which does not have the value 0xf, the following relation
    holds:

        TOS-n = TOS-Fn

    For each field Fn which has the value 0xf, perm8 does not attempt 
    to assign TOS-n. Any permutation of 8 values can be implemented 
    with perm8, in addition to duplication of values.

    For example, to implement the Joy swap operator:

        0xffffff01 perm8    -- switches TOS-0 and TOS-1

    The other rollup-like operators can also be implemented with perm8.

    The dup8 operator also takes a single numerical operand 
    formatted in the same way as perm8. However, dup8 adds its results
    on top of the stack rather than overwriting the items already
    on the stack. This makes dup8 more like dup/dig Joy operators.

    For example, to implement dup:

        0xfffffff0 dup8

----- Strings -----

    Babel has built-in support for the UTF-8 encoding. Since all ASCII is
    well-formed UTF-8, this makes support for UTF-8 an obvious choice. 
    Internally, Babel stores strings in UTF-32/UCS-4 encoding. Babel does
    not have built-in support for UTF-16/UCS-2 (Windows Unicode encoding).

    Operators:

    str2ar

        This operators assumes a UTF-8 input string and generates
        an array of UTF-32/UCS-4 values.

    ar2str

        This operator assumes a UTF-32/UCS-4 array, respectively,
        and generates a UTF-8 string of characters as output

    You can convert a char array to a char list by using the ar2ls operator.

    Once a string has been converted into list or array form, C-style
    string manipulations (e.g. strlen, strcat, etc.) can be performed using
    the ordinary Babel list and array operators.

    If you give a Babel string to cprintf it may result in unexpected
    behavior since Babel strings are UTF-8 encodings which will not be 
    correctly interpreted by code that is expecting ASCII input. 

    Use stdout instead.

    ----- Lower- and upper-case

    Case management is language-specific. Babel has built-in support for
    English upper-case and lower-case operators. These operate on Babel 
    character lists or character arrays.

    lc_eng
    uc_eng

    ----- Converting to/from C strings

    C strings are null-terminated. Babel strings are not (so they can
    be efficiently concat'd using the arcat* operators). Use:

    b2c
    c2b

    ... operators to convert back and forth.

    NOTE:
        Would like to eliminate these operators and use a "strip" operator
        to strip off any trailing nulls in a byte-sequence.

    ----- ASCII encodings of Unicode

    Use the \U{} escape inside a double-quote string to specify a 
    unicode character code point (in hex):

    "\U{263A}"  -- This reduces to a single-character: smiley
                -- Babel will encode this string in UTF-8 format


----- Windows -----

    see tcc/examples/hello_win.c

memory allocation (OLD NOTES)
-----------------------------

    REF-COUNTING DOES NOT SOLVE ALL PROBLEMS. Consider two 1-element inte's
    each pointing at the other. Or, consider a large sub-graph with only one
    inte element pointing to it... once the ref-count of that head goes to
    zero, the entire sub-graph still remains active as it consist of many 
    elements all pointing at one another.

    Let-scoping, however, permits this kind of teardown.

    * All bstruct elements (inte, leaf and tptr) will have a field for 
      ref-counting, called the r-field. The r-field will be placed previous
      to the s-field (that is, at index: entry0 - 2). In general, in order 
      for a bstruct to be considered "consistent", each r-field must have a 
      correct count value, that is, it must match the number of references
      to that element, from within the bstruct. Otherwise, the bstruct is
      considered "inconsistent".

      Certain special elements will be permitted to have a value of -1 in
      the r-field, which will indicate that the field is unused. A bstruct
      with -1 values in one or more r-fields will be considered consistent
      as long as the bstruct is a BVM and the r-fields can be mapped to 
      operator-temporary memory. In practice, only the interpreter will be
      permitted to create consistent bstructs with -1 in the r-field entry.
      The interpreter will be responsible to ensure consistency of bstructs
      during save-and-restore.

      Whenever any pointer (entry in an interior-arry or tptr) is updated,
      the pointer being overwritten must have its r-field updated, and the
      new pointer must also have its r-field updated.

      nil always has r-field = -3

      The maximum ref-count value of r-field is 2^(MWORD_BIT_SIZE-1)-1. 
      That is, if the MSB of r-field is set, then the value is not a 
      ref-count and is instead a type code.

        type code       meaning
        ------------------------------
            -1          uncounted; non-specific
            -2          service memory
            -3          nil
            -4          ref-count error
            -5          pacman
            -6          ustack
            -7          dstack
            -8          rstack
                        
    Allocation types:

    1) Interpreter service memory
        just uses malloc/free
        can NEVER be a "live" part of any bstruct
        e.g. the jump-table and other interp_init collateral

    2) Pacman memory
        Used for operator-temporary memory
        Any stack-noise results in moving this memory to let-scope
            dup, cp, swap, etc.
        Implemented as a single contiguous block of memory (e.g. 2MB)
        Each element in pacman memory has r-field set to -1
        Uses a single reservoir-pointer to allocate/deallocate

    3) Spine memory
        The spines of dstack, ustack, etc. are fixed-size and are 
        allocated using a simple reservoir allocation system.
        r-fields set to -1?

        NOTE: During save-and-restore, bstruct elements with -1 r-fields
        may be converted to normal, let-scoped memory.

    4) Let-scoped memory

        Let-scoped memory is managed at two-levels:

        a) inter-let-scope

        This level acts the same as C-style stack allocation - variables
        created within the current scope will be freed when the current
        scope is closed. Use the 'prom' operator to promote a particular
        piece of memory up to a higher scope.

        b) intra-let-scope

        Within a given scope, significant memory thrash can occur. Such 
        thrash can only be considered a memory leak when it accrues unused 
        memory sufficient to crash an idling while loop, etc. There are 
        innumerable ways for the programmer to accidentally create this
        situation unless some kind of memory reclamation is used.

        Babel uses a free-heap to manage intra-let-scope allocation. Whenever
        the r-field of a bstruct element reaches 0 in the current let-scope,
        the associated element is placed on the free-heap.

        Future optimization may implement the use of dedicated free-lists for
        1-entry, 2-entry, hash-sized and tptr-sized bstruct elements. All
        other sizes will be handled through the free-heap. 

        See http://en.wikipedia.org/wiki/Binary_tree#Arrays for 
        implementation ideas

    Other issues:
    -------------

        Initial allocations:

            ISM (not counted)
            2MB pacman memory
            2MB spine
            2MB initial let-scope allocation

        Additional allocation:

            If more memory is required, it is added by a 2MB allocation from
            the system, according to the type. All memory allocations except
            ISM are counted against the BVM_MAX_ALLOC limit, which cannot be
            exceeded.

            If no more memory is available from the system, the interpreter
            will attempt to save off the BVM and exit with a message 
            explaining the insufficient memory (part of the ISM includes
            a special unused reserve for this purpose).

            If the BVM has reached BVM_MAX_ALLOC, the interpreter will 
            attempt to GC/defrag by save-and-restore of the BVM. If this 
            fails to free up memory, the interpreter will save the BVM and 
            exit with a message. The user can manually override BVM_MAX_ALLOC
            from the command-line and reinvoke the saved BVM, if desired, to
            continue execution.

            While the let-scope allocation pool is increased in size by
            2MB, each let-scope is initialized with just 4KB memory and this
            grows by 4KB increments as more memory is required.

            Let scope pages are never shared between scopes.

DONE-ISH
    - sexpr (super task)
        - Nested text-block syntax
        - sigils:
                stack
            $   string
            %   hash
            @   list
            *   ptr array
            #   lexical
            ,   same-as-whitespace
            ?   is? e.g.: nil? odd? even? +ve? -ve?
            ^   preserving (non-zapping)
        - first-element of square-bracket is numeric... parses to val-array
        - first-element of square-bracket is quote... parses to ptr-array
            [1 2 3 4] === [val 1 2 3 4]
            ['a' 'b' 'c' 'd'] === [ptr 'a' 'b' 'c' 'd']
        - single-element square-bracket ... parses to macro-expander:
            [foo] === [mx "foo"]
        - colon is equivalent to tag:
            [: foo] === [tag foo]


BUGS

    - collect on an empty stack causes segfault

    - segfault on .sp from command-line

        eval.c:200
        mword *tag = get_rstack_entry_tag(this_bvm,rstack_ith(this_bvm,0));

        Segfaults due to non-empty rstack with malformed rstack entry

    - trie_exists may have bug in bpdl_code_list -> BPDL_LIST_LABEL_ENTRY

    - Add livelock-detect to _op_restart code in interp.c

    - REWORK AND CLEAN-UP DLIST CONSTANTS!!!
        Tons of bare constants all over the place! No rational 
            and consistent system

    - Gratuitous call to trie_new_cell() in trie_insert() ...
        only create new cell if not already existing!

    - dstack is created in bvm_new... don't... just make it a requisite
        piece of a BVM... do we need a "bvm_new_init"?


    - FIX CLEANUP: in eval.c, there are several _ith(this_bvm-rstack,0)...
        these should be replaced with rstack_ith()

    - Why do we need string_b2c() again?? Just eliminate... bstrings are already
        C-compatible

    - inline_bpdl should check that quote-array-length is greater than 2

    - slurp needs to check if file is zero-size and act accordingly

    - Move str2ar into sexpr ... there's no reason these should be separate stages

    - Some concept of a "null BVM"?? This is a "dummy" BVM that permits code-injection
        at the interpreter-level. In fact, could exist solely as a bvm_cache structure
        ^^^dangerous because it breaks symmetry


