INDEXING NOTATION:
Nested text-blocks
P-expressions

-- Babel Operator Reference

Note: Stack diagrams are shown under the "Stack effect" section. The item
next to the vertical bar '|' is TOS (Top-Of-Stack), the arrow separates
before (LHS) and after (RHS) execution of the operator. Unless otherwise
indicated, the rest of the stack is left as-is.

Upper-case means "One or more pointers or values"
Lower-case means "a single value"

- Non-alphanumeric operator names

To provide a short-hand for certain common operators and make Babel 
operators more recognizable in terms of the operators used in other 
languages, I have decided to create a variety of non-alphanumeric
operator aliases. Because these aliases may be particularly cryptic
when first encountered, I have collected them in one place here:

       Symbol       Operator        Mnemonic
      ------------------------------------------------------------------
        *2          dup             double TOS
        @           trav            what is AT this location?
        ?           sel             a question
        ??          cond            a big question
        %%          hash8           Perl hash sigil: %
        #           size            number-of
        #8          size8            "    "
        ##          len             number-of (lists take up more space)
        !           eval            do it!
        <<          stdout8         like cout <<
        >>          stdinln8        like cin >>
        <<<         spit8           like stdout8 but going all the way to file
        >>>         slurp8          like stdinlin8 but coming all the way from file
        <->         swap            reverse TOS and TOS-1
        <-          down            stack on left, moving left is going "down" 
        ->          up              stack on left, moving right is going "up"    
        !!          call            do it!!
        +           ciadd           same as C
        -           cisub           same as C
        *           cimul           same as C
        /           cidiv           same as C
        %           curem           same as C
        =           ceq             same as C
        <           cilt            same as C
        >           cigt            same as C
        >=          cige            same as C
        <=          cile            same as C
        u+          cuadd           
        u-          cusub
        u*          cumul
        u/          cudiv
        u<          cult
        u>          cugt
        u>=         cuge
        u<=         cule
        &           cand            same as C
        |           cor             same as C
        ^           cxor            same as C
        ~           cnot            instead of !
        ~&          cnand           see ~
        ~|          cnor            see ~
        ~^          cxnor           see ~
        ~=          cne             see ~
        &&          and             same as C
        ||          or              same as C
        ~~          not             see ~
        |.|         ciabs           like the math operator
        ==          cmp             big equality
        ...         each            traversing a list
        $           show            Perl scalar sigil
        %d          ci2dec          like printf
        %u          cu2dec          like printf
        %x          cu2hex          like printf
        $d          dec2ci          reverse of printf
        $x          hex2cu          reverse of printf
        .           cat8            like the Perl operator

- Arithmetic Operators

    Note: The arithmetic operators are all prefixed with 'c' because
    Babel will have its own native number format and arbitrary-precision
    arithmetic at some point in the future.
 
    - cuadd (u+)
        C-style unsigned addition
        Adds two mwords on TOS (Top-Of-Stack) 
    
        Example: 
            [2] [3] cuadd

            Leaves 5 on TOS

        Note: If you don't know what "unsigned" means then you should use 
        the 'ci' arithmetic operators.

        Stack effect:
            {a} {b}| -> {a+b}|

    - cusub (u-)
        C-style unsigned subtraction
        {a} {b}| -> {a-b}|

    - ciadd (+)
        C-style integer addition
        {a} {b}| -> {a+b}|

    - cisub (-)
        C-style integer subtraction
        {a} {b}| -> {a-b}|

    - ciabs (|.|)
        C-style absolute-value
        {a}| -> {abs(a)}|

    - cumul (u*)
        C-style unsigned multiplication
        {a} {b}| -> {lo(a*b) hi(a*b)}|

        Note: The result of multiplication is two mwords, so it is stored
        in a leaf array of size 2.

    - cudiv (u/)
        C-style unsigned division
        {a} {b}| -> {a/b}|

    - curem (%)
        C-style unsigned remainder (usually termed "mod")
        {a} {b}| -> {a%b}|

    - cimul (*)
        C-style integer multiplication
        {a} {b}| -> {lo(a*b) hi(a*b)}|

        See also: cumul

    - cidiv (/)
        C-style integer division
        {a} {b}| -> {a/b}|

    - cirem
        C-style integer remainder (usually termed "mod")
        {a} {b}| -> {a%b}|

- Shift Operators

    - cushl/shl
        C-style unsigned shift-left
        {a} {b}| -> {a<<b}|
        
    - cushr/shr
        C-style unsigned shift-right
        {a} {b}| -> {a>>b}|
        
    - cashr/ashr
        C-style arithmetic shift-right
        {a} {b}| -> {a>>b}|

        Performs an arithmetic shift-right which is suitable for dividing 
        a signed (integer) value by a power of 2

    - curol/rol
        C-style unsigned rotate-left
        {a} {b}| -> {a rol b}|

    - curor/ror
        C-style unsigned rotate-left
        {a} {b}| -> {a ror b}|

- Bitwise Logic Operators
    Babel has 16 logic operators F0-Ff. Each one implements the Boolean
    function of two bits whose numerical value when the truth-table is 
    read vertically is the number of the operator. Since most people don't
    know what this means, Babel also provides aliases for the ordinary 
    Boolean operators.

    - Fx
        {a} {b}| -> {a Fx b}|

    - cand (&)
        C-style bitwise AND
        {a} {b}| -> {a & b}|
        
    - cnand (~&)
        C-style bitwise NAND
        {a} {b}| -> !{a & b}|

    - cor (|)
        C-style bitwise OR
        {a} {b}| -> {a | b}|

    - cnor (~|)
        C-style bitwise NOR
        {a} {b}| -> !{a | b}|

    - cxor (^)
        C-style bitwise XOR
        {a} {b}| -> {a ^ b}|

    - cxnor (~^)
        C-style bitwise XNOR
        {a} {b}| -> !{a ^ b}|

    - cnot (~)
        C-style bitwise complement
        {a}| -> ~{a}|

- Comparison Operators

    - cne (~=)
        C-style not-equal
        {a} {b}| -> {a != b}|
        
    - ceq (=)
        C-style equal
        {a} {b}| -> {a == b}|
        
    - cult (u<)
        C-style unsigned less-than
        {a} {b}| -> {a < b}|

    - cule (u<=)
        C-style unsigned less-than-or-equal
        {a} {b}| -> {a <= b}|

    - cugt (u>)
        C-style unsigned greater-than
        {a} {b}| -> {a > b}|

    - cuge (u>=)
        C-style unsigned greater-than-or-equal
        {a} {b}| -> {a >= b}|

    - cilt (<)
        C-style integer less-than
        {a} {b}| -> {a < b}|

    - cile (<=)
        C-style integer less-than-or-equal
        {a} {b}| -> {a <= b}|

    - cigt (>)
        C-style integer greater-than
        {a} {b}| -> {a > b}|

    - cige (>=)
        C-style integer greater-than-or-equal
        {a} {b}| -> {a >= b}|

- I/O Operators

    - cprintf
        "C-style printf()"

        Permits printing of C-style (null-terminated) strings with a format
        specifier.

        {x} {"format-specifier"}| -> |

        Prints x according to a standard printf() format specifier.

        Prefer stdout

    - cprints
        "C-style printf('%s')"

        Similar to cprintf but prints a plain-string

        {"C-string"}| -> |

        Prefer stdout

    - slurp/slurp8 (>>>)
        Named after the Perl idiom

        Slurps an entire file to an array (or array8)
        {"filename"}| -> {X}|

        X is the contents of the named file.

    - spit/spit8 (<<<)
        Play on words - opposite of slurp. Writes an array (or array8) 
        to file. Overwrites existing file. Creates file if it does not 
        exist.

        {X} {"filename"}| -> |

    - journal8
        Same as spit8 but appends to existing file. Creates file if it does
        not exist.

        {X} {"filename"}| -> |

    - stdout
        Prints an array to STDOUT as UCS-4 characters
        {"string"}| -> |

    - pr/stdout8 (<<)
        Prints an array8 to STDOUT in UTF-8 encodin
        {"string"}| -> |

    - stdinln (>>)
        Reads from STDIN (standard input) until newline
        This operator is byte-wise so it places an array8 on TOS
        | -> {"string"}|

- bstruct Operators

    - msize
        Puts MWORD_SIZE on TOS

    - trav (@)
        Traverses a bstruct.

            [X] [(Y)] trav

        Traverses bstruct X according to the sequence of offsets specified 
        in list Y.

    - paste
        Writes into a bstruct.

            [X] [(Y)] trav

        Writes into bstruct X according at the location found by traversing
        the sequence of offsets specified in list Y.

    - span
        Makes a "spanning array" of the bstruct on TOS
        X| -> Y
        ... where Y is an array containing a pointer into every array and href in X

    - cp (ND)
        Named after the Unix command. Does a deep-copy of a bstruct.

        [X]| -> [copy-of-X]|

        Example:
            [(0 (1))] cp

            There is now (0 (1)) on TOS but the original object
            still exists as-is.

        This operator is recursive.            

    - unload
        Unloads a bstruct to an offset-relative form

    - load
        Flattens a relative-offset Babel structure into its literal 
        memory pointer footprint. This operator is applied by the 
        interpreter to a Babel file when it is initially loaded from file 
        into memory.

    - dump
        Prints TOS to STDOUT in Graphviz dot-language format

    - show ($)
        Prints TOS to string format

    - mu
        "Memory usage" - by analogy to Unix 'du'
        Returns the total memory usage of the object on TOS measured in 
        mwords.
        {X}| -> {mu(X)}|
        [X]| -> {mu(X)}|

        This operator is recursive

    - nlf
        "Number of leaf-arrays"
        Returns the total number of leaf-arrays in the object on TOS
        {X}| -> {1}|
        [X]| -> nlf(X)|

        This operator is recursive

    - nin
        "Number of interior-arrays"
        Returns the total number of interior-arrays in the object on TOS
        {X}| -> {0}|
        [X]| -> nin(X)|

        This operator is recursive

    - nhref
        "Number of hash-references"
        Returns the total number of hash-references in the object on TOS

    - nva
        "Number of values"
        Returns the total number of values in the object on TOS
        {X}| -> {nva(X)}|
        [X]| -> {nva(X)}|

        This operator is recursive

    - npt
        "Number of pointers"
        Returns the total number of pointers in the object on TOS
        {X}| -> 0|
        [X]| -> npt(X)|

        This operator is recursive

- Array Operators

    - s
        Reads the s-field and places it on TOS
        {X}| -> {s(X)}|
        [X]| -> {s(X)}|

    - size (#)
        Puts the array size on TOS
        {X}| -> {size(X)}|
        [X]| -> {size(X)}|

    - size8 (#8)
        Puts the 8-bit array length on TOS
        {X}| -> {size8(X)}|
        [X]| -> {size8(X)}|

    - islf
        Tests if TOS is a leaf-array
        {X}| -> {1}|
        [X]| -> {0}|

    - isin
        Tests if TOS is an interior-array
        {X}| -> {0}|
        [X]| -> {1}|

    - ishref
        Tests if TOS is a hash-reference

    - slice (ND)
        Puts a slice of an array on TOS
        {X} {a} {b}| -> {X[a..b]}|
        [X] {a} {b}| -> [X[a..b]]|

        Read [a..b] as "from a to b"

    - slice8/slice1

    - newlf
        Creates a new leaf-array of size x and leaves it on TOS
        {x}| -> {leaf-array-of-size-x}|

    - newin
        Creates a new interior-array of size x and leaves it on TOS
        {x}| -> {interior-array-of-size-x}|

    - free
        Frees the array on TOS - NOT recursive. See del.

    - del (D)
        Named after the C++ delete operator

        Frees (de-allocates) a leaf-array or interior array created with 
        the newlf or newin operators. Be careful with this operator - 
        everything accessible from TOS will be deleted. In particular:

            root del

        ... will crash the interpreter.

    - trunc (D)
        Truncates an array X to length y:
        {X} {y}| -> {X[0..y]}|
        [X] {y}| -> [X[0..y]]|

    - cxr (D)
        By analogy to Lisp's car/cdr, where car = c0r and cdr = c1r, etc.

        Returns the xth element of array A:

        {A} {x}| -> {A[x]}|
        [A] {x}| -> [A[x]]|

        Note that cxr is a degenerate case of slice:
            [x] cxr <==> [x] [x] slice

        Make this into a pseudo-operator?

    - paste8/paste1

    - cut
        Cuts an array - opposite of cat

        The cut operator only cuts in one place. If you want more complex 
        behavior, convert the array to a list, then use append/part

        A 0| -> nil A|
        A x| -> A[0:(x-1)] A[x:len(A)]|     0 < x < len(A)
        A len(A)| -> A nil|

        Note that cut does not use entry-addressing. If you cut A at 0, then
        you will always get 'nil A' on the stack. The cut operator uses
        boundary-addressing instead, where the boundary before entry 0 is 
        defined as the 0th boundary and the boundary between entry 0 and 
        entry 1 is the 1st boundary, and so on.

    - cat/cat8 (.)
        Concatenate two arrays of the same type. If you want more complex 
        behavior, convert your arrays to lists, then use append/part

    - cmp (==)
        does a memcmp
        A B| -> { 0, A==B
                {-1, A < B 
                { 1, A > B

    - move
        an in-array memmove
        A x y z| -> B  (A[x:y] pasted at A[z], all other words same)

    - move8
        See move

    - ar2ls
        Convert array to list. For interior-arrays, undoes bons.

        Leaf-array on TOS:
            {1 2 3}| -> (1 2 3)|

        Interior-array on TOS:
            [a b c]| -> (a b c)|

- String operators

    - str2ar
        "Convert string to array"

        "Expands" a string so that each character is one value of a leaf-
        array. The input string must be valid UTF-8 (UTF-8 is a superset
        of ASCII) and each value of the resulting array will be the 
        Unicode codepoint corresponding to each UTF-8 character.

        {"string"}| -> {X}|

        Where X is a leaf-array of Unicode code-points.

    - ar2str
        "Convert array to string"
        Undoes str2ar, see above.

        {X}| -> {"string"}|

    - cu2dec (%u)
        Converts an C-style unsigned value to its ASCII decimal 
        representation

        {x}| -> {"string"}|
    
    - ci2dec (%d)
        Converts an C-style integer value to its ASCII decimal 
        representation

        {x}| -> {"string"}|

    - dec2ci ($d)
        Undoes ci2dec, see above

    - cu2hex (%x)
        Converts an C-style unsigned value to its ASCII hexadecimal 
        representation

        {x}| -> {"string"}|

    - hex2cu ($x)
        Undoes cu2hex, see above

- List Operators

    - car
        Named after the venerable Lisp operator
        Returns the left side of a cons

        [cons(X,Y)]| -> {X}|
        [cons(X,Y)]| -> [X]|

        Equivalent to: 0 cxr (see above)

    - cdr
        Named after the venerable Lisp operator
        Returns the right side of a cons

        [cons(X,Y)]| -> {Y}|
        [cons(X,Y)]| -> [Y]|

    - isnil
        Tests if TOS is nil
        [nil]| -> {1}|
        {X}|   -> {0}|
        [X]|   -> {0}|

        For all X != nil

    - cons
        Named after the venerable Lisp operator
        Constructs one list from two
        [X] [Y]| -> [cons(X, Y)]|

        Note: 
            [X] [Y] cons car     Leaves [X] on TOS
            [X] [Y] cons cdr     Leaves [Y] on TOS

    - uncons
        Undoes cons
        [cons(X, Y)]| -> [X] [Y]|

    - bons
        Undoes ar2ls on an interior-array.

        Mnemonic: "Babel cons"... since it's like consing together an entire list
        into an "oversize" cons box.

    - len (##)
        List length

    - ls2lf
        Undoes ar2ls on a leaf-array

    - append
        appends a list of lists
        ( ('a') ('b' 'c') ('d' 'e') ('f' 'g') ) append
            -> leaves ('a' 'b' 'c' 'd' 'e' 'f' 'g') on TOS

    - part
        Partitions a list - opposite of append
        ( 'a' 'b' 'c' 'd' 'e' 'f' 'g') (1 3 5) part
            -> leaves ( ('a') ('b' 'c') ('d' 'e') ('f' 'g') ) on TOS

    - rev
        (1 2 3) rev -> leaves (3 2 1) on TOS

- Hash Operators

    Unlike most Babel operators, the hash operators do not zap all their 
    input operands. The hash itself is left on TOS. This eliminates the 
    need for a separate "makeha" operator and is consistent with multiple
    operations on the same hash. Don't forget to zap the hash off TOS when
    you are done:

        my_hash ["foo"] [42] inskha ["bar"] [13] inskha zap  -- done

    - insha
        Insert into hash:
        
            my_hash [{0 0 0 0}] ["foo"] hash8 [42] insha

        ... inserts the value 42 into my_hash with the key "foo". Does not
        store the key in the hash.

    - inskha
        Insert by key into hash:
        
            my_hash ["foo"] [42] inskha

        ... inserts the value 42 into my_hash with the key "foo". The
        key is stored in the hash-entry.

    - luha
        Look up a hash-entry

    - exha
        Test existence in hash:
        
            my_hash [{0 0 0 0}] ["foo"] hash8 exha

        Leaves 1 on TOS if the associated entry is found in the hash, 
        otherwise, leaves 0 on TOS.

    - rmha
        Remove from hash:
        
            my_hash [{0 0 0 0}] ["foo"] hash8 rmsha

        ... removes the the entry from my_hash with the key "foo" if it 
        exists.

    - keysha
        Extracts all "keys" from the hash. Note that the extracted keys
        are actually hash-references, not symbolic keys. The symbolic
        keys can be recovered with the lukha operator.

    - newref
        Creates a new hash reference on TOS from a hash value:

            ["foo"] hash8 newref  -- There is now an href to foo on TOS

    - lukha
        Look up a hash-entry's key

    - lurha
        Look up a hash-entry's ref-count

    - enref/unref
    - deref
    - ls2ha
    - ha2ls

    - diffha
        Diffs the hashes on TOS
        L R| -> (L n !R) (!L n R) (L n R)|

        To test for sameness, check if TOS-1 and TOS-2 are both 
        nil or both not nil.

    - merge
        Would be nice to have a merge operator that can "undo" diff

    - hash/hash8 (%%)
        Hashes a sequence of bytes (hence the '8')

        Stack effect:
            {"string"}| -> {w x y z}|
            A hash is 4 mwords in size

    - phash/phash8
        Performs a progressive hash

- Namespace Operators
    - insns
        inserts an entry into a namespace

    - exns
        tests for existence of a namespace entry

    - rmns
        removes a namespace entry

    - dirns
        like unix ls

    - cpns/mvns/mkdir

    - treens
        puts a tree with every namespace name on TOS:
            /
            +foo
            ++baz (dir)
            ++bop
            +bar
        ('' ('foo' ('baz') 'bop') ('bar') )

    - pwd
        puts the pwd on TOS

    - cd
        foo cd -> sets pwd to <pwd>/foo
        /foo cd -> sets pwd to /foo
        .. cd -> sets pwd to parent of pwd
        ../bar cd -> sets pwd to the sibling of pwd, 'bar'

    - basename
        '/foo/hello/world' basename -> '/foo/hello' 'world' on TOS

    - dir
        . dir -> puts a directory listing of pwd on TOS... e.g. ('foo' 'bar' 'baz' 'gimble')

    - switchns 
        changes the root namespace structure

- Utility Operators

    - rand
        Places an array of x random values on TOS. Uses the Mersenne Twister
        PRNG.
        {x}| -> {R}|

        len(R) = x, each value of R is pseudo-random

    - sleep
        Pauses execution for x seconds:
        {x}| -> |

    - argv
        Named after the C identifier

        Places a list of strings on the stack corresponding to the arguments 
        passed to Babel on the commandline.
        | -> [args]|

    - fnord
        Does nothing
        Stack effect:
            | -> |

    - bzip2
    - bunzip2
        (de)compresses an array using the bzip2 compressor

- Stack Operators

    - zap
        Named after the Joy operator
        Removes the TOS

    - sel (?)
        Selects one of the top two values on the stack:
        {f} {X} {Y}| -> {X}|
        {t} {X} {Y}| -> {Y}|
        {f} [X] {Y}| -> [X]|
        {t} [X] {Y}| -> {Y}|
        etc.

        Where f = 0 and t != 0

    - dup (*2)
        Named after the Joy operator
        Duplicates the TOS. Shallow-copy.
        {X}| -> {X} {X}|
        [X]| -> [X] [X]|

    - swap (<->)
        Named after the Joy operator
        Swaps the top two items on the stack.
        {X} {Y}| -> {Y} {X}|
        [X] {Y}| -> {Y} [X]|
        etc.

    - down (<-)
        Analogous to doing a cdr on the stack itself. If the code_ptr 
        becomes nil after executing one or more downs without a balancing 
        up, as many ups as are required to undo the downs will be executed
        automatically.
    
    - nest
        Analogous to doing a car on the stack. If the code_ptr becomes
        nil after a nest and with no intervening up, an up will be 
        executed automatically.

    - up (->)
        Undoes down/nest.

    - take
        Takes TOS items from the stack and puts them into a list. Does not
        zap the items (should it?)

    - give
        Undoes take

    - clear
        Empties the stack

    - depth
        Places the depth of the stack on TOS. To gather up the entire stack
        into a list:
    
            depth take

- Truth-value Operators
    
                    { 1 if TOS=0 or TOS=nil
    is_false(x) ->  {
                    { 0 otherwise

    - and (&&)
        Places (!is_false(TOS) & !is_false(TOS-1)) on TOS

    - or (||)
        Places (!is_false(TOS) | !is_false(TOS-1)) on TOS

    - not (~~)
        Places is_false(TOS) on TOS

- Flow-control Operators

    - eval (!)
        Named after the Perl function
        Evaluates TOS
        [X]| -> |

    - goto
        Classic goto
        [X]| -> |

    - call (!!)
        Saves the current location in code, then does a goto
        [X]| -> |

    - ret
        Returns to the last location saved by a call
        | -> |

    - last
        Breaks out of current loop

    - next
        Goes to next iteration of current loop

    - cond (??) 
        --
            (([x] 0 gt)
                ("positive" say)
            ( [x] 0 lt)
                ("negative" say)
            ( [x] 0 eq)
                ("zero" say))
        cond

- Iteration Operators

    - times
        Like eval but executes n iterations. Use 'last' or 'next' to modify
        the loop's behavior.

        [X] n| -> |

        Example:

            ([(1 2 3 4 5)] give
            --
                [(cuadd)]
            [4] times)

    - while
        Classic while

            ([0]
            [(dup [1] cuadd)]
            [([10] cult)]
            while)

    - loop
        Loops indefinitely

    - each (...)
        Iterates across a list
            [0]
            --
                (cuadd)
                (1 2 3 4)
            each

    - eachar
        Iterates across an array

            [0]
            --
                (cuadd)
                [1 2 3 4]
            eachar

    - zipeach
    - carteach

- Babel Virtual Machine (BVM) Operators

    - babel
        This operator "execs" a loaded BVM on TOS

    - root
        Puts the root pointer to the entire virtual-machine on TOS
        | -> [root]|

    - bvmstep
    - mkbvm
    - bvmkill
    - halt
    - die
        Exits a virtual machine
    - fork
    - system (equivalent to Perl's system())
    - shell (equivalent to Perl's back-tick quotes)
    - exec (does a fork/exec in Linux; CreateProcess in Windows)

- Idiomatic Operators
    - strint
    - macint
    - interpol
    - cart
        --
            ((1 2 3 )
            ( 4 5 6 ))
        cart

        TOS: (((1 4) (1 5) (1 6)) ((2 4) (2 5) (2 6)) ((3 4) (3 5) (3 6)))
        
        Works for all dimensions

    - zip
        --
            (( 1  2  3  4 )
            (  5  6  7  8  9 )
            (  10 11 12 13 14 15 ))
        zip

        TOS: ((1 5 10) (2 6 11) (3 7 12) (4 8 13) (nil 9 13) (nil nil 15))

    - transpose
        multi-dimensional transpose as "dimensional permutation"
        <x,y,z> -> <y,x,z> or <x,y,z> -> <y,z,x>
        We can restrict this to "dimensional rotation", then simplify
        to rotation by ONE:
        <x,y,z> -> <z,x,y>
        repeated application of transpose operator will iterate through
        all dimensional rotations until returning to the original

        <x,y> -> <y,x> -> <x,y>
        <x,y,z> -> <z,x,y> -> <y,z,x> -> <x,y,z>
        <w,x,y,z> -> <z,w,x,y> -> <y,z,w,x> -> <x,y,z,w> -> <w,x,y,z>
        etc.

    - sort 
    - uniq
    - filter -> Perl's grep
        --
            ( 2 cugt )
            ( 1 2 3 4 5 )
        filter

        Leaves ( 3 4 5 ) on the stack

