INDEXING NOTATION:
Nested text-blocks
P-expressions

-- Babel Operator Reference

Note: Stack diagrams are shown under the "Stack effect" section. The item
next to the vertical bar '|' is TOS (Top-Of-Stack), the arrow separates
before (LHS) and after (RHS) execution of the operator. Unless otherwise
indicated, the rest of the stack is left as-is.

Upper-case means "One or more pointers or values"
Lower-case means "a single value"

- Arithmetic Operators

    Note: The arithmetic operators are all prefixed with 'c' because
    Babel will have its own native number format and arbitrary-precision
    arithmetic at some point in the future.

    - cuadd
        C-style unsigned addition
        Adds two mwords on TOS (Top-Of-Stack) 
    
        Example: 
            [2] [3] cuadd

            Leaves 5 on TOS

        Note: If you don't know what "unsigned" means then you should use 
        the 'ci' arithmetic operators.

        Stack effect:
            {a} {b}| -> {a+b}|

    - cusub
        C-style unsigned subtraction
        {a} {b}| -> {a-b}|

    - ciadd
        C-style integer addition
        {a} {b}| -> {a+b}|

    - cisub
        C-style integer subtraction
        {a} {b}| -> {a-b}|

    - ciabs
        C-style absolute-value
        {a}| -> {abs(a)}|

    - cumul
        C-style unsigned multiplication
        {a} {b}| -> {lo(a*b) hi(a*b)}|

        Note: The result of multiplication is two mwords, so it is stored
        in a leaf array of size 2.

    - cudiv
        C-style unsigned division
        {a} {b}| -> {a/b}|

    - curem
        C-style unsigned remainder (usually termed "mod")
        {a} {b}| -> {a%b}|

    - cimul
        C-style integer multiplication
        {a} {b}| -> {lo(a*b) hi(a*b)}|

        See also: cumul

    - cidiv
        C-style integer division
        {a} {b}| -> {a/b}|

    - cirem
        C-style integer remainder (usually termed "mod")
        {a} {b}| -> {a%b}|

- Shift Operators

    - cushl
        C-style unsigned shift-left
        {a} {b}| -> {a<<b}|
        
    - cushr
        C-style unsigned shift-right
        {a} {b}| -> {a>>b}|
        
    - cashr
        C-style arithmetic shift-right
        {a} {b}| -> {a>>b}|

        Performs an arithmetic shift-right which is suitable for dividing 
        a signed (integer) value by a power of 2

    - curol
        C-style unsigned rotate-left
        {a} {b}| -> {a rol b}|

    - curor
        C-style unsigned rotate-left
        {a} {b}| -> {a ror b}|

- Logic Operators
    Babel has 16 logic operators F0-Ff. Each one implements the Boolean
    function of two bits whose numerical value when the truth-table is 
    read vertically is the number of the operator. Since most people don't
    know what this means, Babel also provides aliases for the ordinary 
    Boolean operators.

    - Fx
        {a} {b}| -> {a Fx b}|

    - cand
        C-style bitwise AND
        {a} {b}| -> {a & b}|
        
    - cnand
        C-style bitwise NAND
        {a} {b}| -> !{a & b}|

    - cor
        C-style bitwise OR
        {a} {b}| -> {a | b}|

    - cnor
        C-style bitwise NOR
        {a} {b}| -> !{a | b}|

    - cxor
        C-style bitwise XOR
        {a} {b}| -> {a ^ b}|

    - cxnor
        C-style bitwise XNOR
        {a} {b}| -> !{a ^ b}|

    - cnot
        C-style bitwise complement
        {a}| -> ~{a}|

- Comparison Operators

    - cne
        C-style not-equal
        {a} {b}| -> {a != b}|
        
    - ceq
        C-style equal
        {a} {b}| -> {a == b}|
        
    - cult
        C-style unsigned less-than
        {a} {b}| -> {a < b}|

    - cule
        C-style unsigned less-than-or-equal
        {a} {b}| -> {a <= b}|

    - cugt
        C-style unsigned greater-than
        {a} {b}| -> {a > b}|

    - cuge
        C-style unsigned greater-than-or-equal
        {a} {b}| -> {a >= b}|

    - cilt
        C-style integer less-than
        {a} {b}| -> {a < b}|

    - cile
        C-style integer less-than-or-equal
        {a} {b}| -> {a <= b}|

    - cigt
        C-style integer greater-than
        {a} {b}| -> {a > b}|

    - cige
        C-style integer greater-than-or-equal
        {a} {b}| -> {a >= b}|

- I/O Operators

    - cprintf
        "C-style printf()"

        Permits printing of C-style (null-terminated) strings with a format
        specifier.

        {x} {"format-specifier"}| -> |

        Prints x according to a standard printf() format specifier.

        Prefer stdout

    - cprints
        "C-style printf('%s')"

        Similar to cprintf but prints a plain-string

        {"C-string"}| -> |

        Prefer stdout

    - slurp8
        Named after the Perl idiom

        Slurps an entire file to an array8
        {"filename"}| -> {X}|

        X is the contents of the named file.

    - spit8
        Play on words - opposite of slurp. Writes an array8 to file. 
        Overwrites existing file. Creates file if it does not exist.
        {X} {"filename"}| -> |

    - journal8
        Same as spit8 but appends to existing file. Creates file if it does
        not exist.
        {X} {"filename"}| -> |

    - stdout
        Prints a string to STDOUT (standard output)
        {"string"}| -> |

    - stdinln
        Reads from STDIN (standard input) until newline
        | -> {"string"}|

- bstruct Operators

    - span
        Makes a spanning tree of the bstruct on TOS
        X| -> Y
        ... where Y is a spanning tree of X

    - diff
        Diffs the bstruct on TOS
        L R| -> (L n !R) (!L n R) (L n R)|

        To test for sameness, check if TOS-1 and TOS-2 are both 
        nil or both not nil.

        The results created by diff use uptrs to point into
        the originals

    - merge
        Would be nice to have a merge operator that can "undo" diff

    - cp (ND)
        Named after the Unix command. Does a deep-copy of a bstruct.

        [X]| -> [copy-of-X]|

        Example:
            [(0 (1))] cp

            There is now (0 (1)) on TOS but the original object
            still exists as-is.

        This operator is recursive.            

    - unload
        Unloads a bstruct to an offset-relative form

    - mv
        Moves bstruct A to bstruct B intact

    - rm
        Recursively frees bstruct on TOS
        (cf to simply setting to nil to unlink)

    - load
        Flattens a relative-offset Babel structure into its literal 
        memory pointer footprint. This operator is applied by the 
        interpreter to a Babel file when it is initially loaded from file 
        into memory.

    - bs2gv
        Prints TOS to STDOUT in Graphviz dot-language format

    - bs2str
        Prints TOS to string format

    - flatten
        flattens a bstruct to a list whose cars point at leafs (is this 
        possible? think of loops)

    - mu
        "Memory usage" - by analogy to Unix 'du'
        Returns the total memory usage of the object on TOS measured in 
        mwords.
        {X}| -> {mu(X)}|
        [X]| -> {mu(X)}|

        This operator is recursive

    - nlf
        "Number of leaf-arrays"
        Returns the total number of leaf-arrays in the object on TOS
        {X}| -> {1}|
        [X]| -> nlf(X)|

        This operator is recursive

    - nin
        "Number of interior-arrays"
        Returns the total number of interior-arrays in the object on TOS
        {X}| -> {0}|
        [X]| -> nin(X)|

        This operator is recursive

    - nva
        "Number of values"
        Returns the total number of values in the object on TOS
        {X}| -> {nva(X)}|
        [X]| -> {nva(X)}|

        This operator is recursive

    - npt
        "Number of pointers"
        Returns the total number of pointers in the object on TOS
        {X}| -> 0|
        [X]| -> npt(X)|

        This operator is recursive

- Array Operators

    - s
        Reads the s-field and places it on TOS
        {X}| -> {s(X)}|
        [X]| -> {s(X)}|

    - size
        Puts the array size on TOS
        {X}| -> {size(X)}|
        [X]| -> {size(X)}|

    - lenar8
        (currently arlen8)
        Puts the 8-bit array length on TOS
        {X}| -> {len8(X)}|
        [X]| -> {len8(X)}|

    - islf
        Tests if TOS is a leaf-array
        {X}| -> {1}|
        [X]| -> {0}|

    - isin
        Tests if TOS is an interior-array
        {X}| -> {0}|
        [X]| -> {1}|

    - slice (ND)
        Puts a slice of an array on TOS
        {X} {a} {b}| -> {X[a..b]}|
        [X] {a} {b}| -> [X[a..b]]|

        Read [a..b] as "from a to b", not as an interior-array

    - newlf
        Creates a new leaf-array of size x and leaves it on TOS
        {x}| -> {leaf-array-of-size-x}|

    - newin
        Creates a new interior-array of size x and leaves it on TOS
        {x}| -> {interior-array-of-size-x}|

    - del (D)
        Named after the C++ operator

        Frees (de-allocates) a leaf-array or interior array created with 
        the newlf or newin operators

    - trunc (D)
        Truncates an array X to length y:
        {X} {y}| -> {X[0..y]}|
        [X] {y}| -> [X[0..y]]|

    - cxr (D)
        By analogy to Lisp's car/cdr, where car = c0r and cdr = c1r, etc.

        Returns the xth element of array A:

        {A} {x}| -> {A[x]}|
        [A] {x}| -> [A[x]]|

        Note that cxr is a degenerate case of slice:
            [x] cxr <==> [x] [x] slice

        Make this into a pseudo-operator?

    - paste (D)
        Pastes array X into array Y at offset z. Leaves the result on TOS.

        {X} {Y} {z}| -> {Y written with X at z}|
        [X] [Y] {z}| -> [Y written with X at z]|
        {X} [Y] {z}| -> [Y.0.z written with X ]|

        If len(X)+z > len(Y), then the write is truncated to len(Y)

    - cut
        Cuts an array - opposite of cat

        The cut operator only cuts in one place. if you want more complex 
        behavior, convert the array to a list, then use append/part

        A 0| -> nil A|
        A x| -> A[0:(x-1)] A[x:len(A)]|     0 < x < len(A)
        A len(A)| -> A nil|

        Note that cut does not use entry-addressing. If you cut A at 0, then
        you will always get 'nil A' on the stack. The cut operator uses
        boundary-addressing instead, where the boundary before entry 0 is 
        defined as the 0th boundary and the boundary between entry 0 and 
        entry 1 is the 1st boundary, and so on.

    - cat
        Concatenate two arrays of the same type. If you want more complex 
        behavior, convert your arrays to lists, then use append/part

    - cmp
        does a memcmp (mword sized, cf cmp8)
        A B| -> { 0, A==B
                {-1, A < B 
                { 1, A > B

    - move
        an in-array memmove
        A x y z| -> B  (A[x:y] pasted at A[z], all other words same)

    - move8
        See move

    - ar2ls
        Leaf-array on TOS:
            [1 2 3]| -> (1 2 3)|

        Interior-array on TOS:
            [a b c]| -> (a . (b . (c d)))|

- String operators

    - str2ar
        "Convert string to array"

        "Expands" a string so that each character is one value of a leaf-
        array. The input string must be valid UTF-8 (UTF-8 is a superset
        of ASCII) and each value of the resulting array will be the 
        Unicode codepoint corresponding to each UTF-8 character.

        {"string"}| -> {X}|

        Where X is a leaf-array of Unicode code-points.

    - ar2str
        "Convert array to string"
        Undoes str2ar, see above.

        {X}| -> {"string"}|

    - cu2dec
        Converts an C-style unsigned value to its ASCII decimal 
        representation

        {x}| -> {"string"}|
    
    - ci2dec
        Converts an C-style integer value to its ASCII decimal 
        representation

        {x}| -> {"string"}|

    - dec2ci
        Undoes ci2dec, see above

    - dec2ci
        Undoes ci2dec, see above

    - cu2hex
        Converts an C-style unsigned value to its ASCII hexa-decimal 
        representation

        {x}| -> {"string"}|

    - hex2cu
        Undoes cu2hex, see above

- List Operators

    - car
        Named after the venerable Lisp operator
        Returns the left side of a cons

        [cons(X,Y)]| -> {X}|
        [cons(X,Y)]| -> [X]|

        Equivalent to: 0 cxr (see above)

    - cdr
        Named after the venerable Lisp operator
        Returns the right side of a cons

        [cons(X,Y)]| -> {Y}|
        [cons(X,Y)]| -> [Y]|

    - isnil
        Tests if TOS is nil
        [nil]| -> {1}|
        {X}|   -> {0}|
        [X]|   -> {0}|

        For all X != nil

    - cons
        Named after the venerable Lisp operator
        Constructs one list from two
        [X] [Y]| -> [cons(X, Y)]|

        Note: 
            [X] [Y] cons car     Leaves [X] on TOS
            [X] [Y] cons cdr     Leaves [Y] on TOS

    - uncons
        Undoes cons
        [cons(X, Y)]| -> [X] [Y]|

    - push
        Similar to cons, but reverses the car and cdr:
        [X] [Y]| -> [cons(Y, X)]|

        Read "Push X onto Y"

        Note: 
            [X] [Y] push car     Leaves [Y] on TOS
            [X] [Y] push cdr     Leaves [X] on TOS

    - pop
        Undoes push. Similar to uncons but reverse the car and cdr:
        [cons(Y,X)]| -> [X] [Y]|

    - bons
        "Babel cons"
        conses an entire list into an interior-array

    - lslen

    - append
        appends a list of lists
        ( ('a') ('b' 'c') ('d' 'e') ('f' 'g') ) append

    - rev
        (1 2 3) rev -> leaves (3 2 1) on TOS

    - part
        Partitions a list - opposite of append
        ( 'a' 'b' 'c' 'd' 'e' 'f' 'g') (1 3 5) part
            -> leaves ( ('a') ('b' 'c') ('d' 'e') ('f' 'g') ) on TOS

- Hash Operators
    - insha
    - exha
    - rmha
    - keysha
    - valsha
    - ls2ha
    - ha2ls

- Namespace Operators
    - insns
        inserts an entry into a namespace

    - exns
        tests for existence of a namespace entry

    - rmns
        removes a namespace entry

    - dirns
        like unix ls

    - cpns/mvns/mkdir

    - treens
        puts a tree with every namespace name on TOS:
            /
            +foo
            ++baz (dir)
            ++bop
            +bar
        ('' ('foo' ('baz') 'bop') ('bar') )

    - pwd
        puts the pwd on TOS

    - cd
        foo cd -> sets pwd to <pwd>/foo
        /foo cd -> sets pwd to /foo
        .. cd -> sets pwd to parent of pwd
        ../bar cd -> sets pwd to the sibling of pwd, 'bar'

    - basename
        '/foo/hello/world' basename -> '/foo/hello' 'world' on TOS

    - dir
        . dir -> puts a directory listing of pwd on TOS... e.g. ('foo' 'bar' 'baz' 'gimble')

    - switchns 
        changes the root namespace structure

- Utility Operators

    - rand
        Places an array of x random values on TOS. Uses the Mersenne Twister
        PRNG.
        {x}| -> {R}|

        len(R) = x, each value of R is pseudo-random

    - sleep
        Pauses execution for x seconds:
        {x}| -> |

    - argv
        Named after the C identifier

        Places a list of strings on the stack corresponding to the arguments 
        passed to Babel on the commandline.
        | -> [args]|

    - fnord
        Does nothing
        Stack effect:
            | -> |

    - hash/hash8
        Hashes a sequence of bytes (hence the '8')

        Stack effect:
            {"string"}| -> {w x y z}|
            A hash is 4 mwords in size

    - bzip2
    - bunzip2
        (de)compresses an array using the bzip2 compressor

- Stack Operators

    - zap
        Named after the Joy operator
        Removes the TOS

    - sel
        Selects one of the top two values on the stack:
        {f} {X} {Y}| -> {X}|
        {t} {X} {Y}| -> {Y}|
        {f} [X] {Y}| -> [X]|
        {t} [X] {Y}| -> {Y}|
        etc.

        Where f = 0 and t != 0

    - dup
        Named after the Joy operator
        Duplicates the TOS. Shallow-copy.
        {X}| -> {X} {X}|
        [X]| -> [X] [X]|

    - swap    
        Named after the Joy operator
        Swaps the top two items on the stack.
        {X} {Y}| -> {Y} {X}|
        [X] {Y}| -> {Y} [X]|
        etc.

    - perm
        Fast permutation of the top 8 items on the stack

        A B C ... {p}| -> [perm(p,A,B,C...)]

        Example:

            [0] [1] [2] [0xfffff210] perm
            
            TOS   = 0
            TOS-1 = 1
            TOS-2 = 2

        perm is not restricted to permutations:

            [3] [5] [7] [0xfffff222] perm

            TOS = TOS-1 = TOS-2 = 3

        To leave an item on the stack, use 0xf:

            [2] [4] [6] [0xfffff3f1] perm

            TOS = 2
            TOS = 4
            TOS = 6

    - extr
        Fast extraction of the top 8 items on the stack

        The extr operator uses the same control-word format as perm,
        however, instead of replacing items on the stack, it simply pushes
        copies of the requested items on top of the stack.

            [1] [2] [3] [4] [0xfffff13] extr
        
        Stack is now:

            [1] [2] [3] [4] [3] [1]|

    - stack 
        Like Joy
        A B ...| -> A B ... (A B ...)|

    - unstack
        Like Joy
        (A B ...)| -> A B ...|

- Control-flow Operators

    - eval
        Named after the Perl function
        Evaluates TOS
        [X]| -> |

    - goto
        Classic goto
        [X]| -> |

    - call
        Saves the current location in code, then does a goto
        [X]| -> |

    - ret
        Returns to the last location saved by a call
        | -> |

    - last
        Breaks out of current loop

    - next
        Goes to next iteration of current loop

- Iteration Operators

    - times
        Like eval but executes n iterations. Use 'last' or 'next' to modify
        the loop's behavior.

        [X] n| -> |

    - while
        Classic while

    - times
        (1 2 3 4 5)
        unstack
        --
            (cuadd)
            4
        times

    - cond
        --
            (([x] 0 gt)
                ("positive" say)
            ( [x] 0 lt)
                ("negative" say)
            ( [x] 0 eq)
                ("zero" say))
        cond

    - zipeach
    - carteach
    - eachls
        --
            0
            ( cuadd )
            ( 1 2 3 4 5 )
        eachls

- Babel Virtual Machine (BVM) Operators

    - bvmroot
        Puts the root pointer to the entire virtual-machine on TOS
        | -> [bvmroot]|
    - bvmgo
    - bvmstep
    - mkbvm
    - bvmkill
    - halt
    - die (synonym to bvmquit?)

- Idiomatic Operators
    - strint
    - macint
    - interpol
    - cart
        --
            ((1 2 3 )
            ( 4 5 6 ))
        cart

        TOS: (((1 4) (1 5) (1 6)) ((2 4) (2 5) (2 6)) ((3 4) (3 5) (3 6)))
        
        Works for all dimensions

    - zip
        --
            (( 1  2  3  4 )
            (  5  6  7  8  9 )
            (  10 11 12 13 14 15 ))
        zip

        TOS: ((1 5 10) (2 6 11) (3 7 12) (4 8 13) (nil 9 13) (nil nil 15))

    - transpose
        multi-dimensional transpose as "dimensional permutation"
        <x,y,z> -> <y,x,z> or <x,y,z> -> <y,z,x>
        We can restrict this to "dimensional rotation", then simplify
        to rotation by ONE:
        <x,y,z> -> <z,x,y>
        repeated application of transpose operator will iterate through
        all dimensional rotations until returning to the original

        <x,y> -> <y,x> -> <x,y>
        <x,y,z> -> <z,x,y> -> <y,z,x> -> <x,y,z>
        <w,x,y,z> -> <z,w,x,y> -> <y,z,w,x> -> <x,y,z,w> -> <w,x,y,z>
        etc.

    - sort 
    - uniq
    - filter -> Perl's grep
        --
            ( 2 cugt )
            ( 1 2 3 4 5 )
        filter

        Leaves ( 3 4 5 ) on the stack


