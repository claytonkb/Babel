Babel guts

This document describes the internals of the Babel interpreter.

Note that this document does not detail the syntax of Bipedal (Babel Program
Description Language).

----- mword

    MWORD is short for machine-word and stands for an unsigned int or 
    pointer whose size is the native word size of the machine. In other words,
    an mword is either a 32-bit or 64-bit unsigned int or unsigned int pointer
    that is treated like a void pointer (to put it in C terminology).

    MWORD_SIZE is the native word size (in bits) divided by 8 bits per byte.
    On 32-bit machines, MWORD_SIZE is 4. On 64-bit machines, it is 8.

----- bstruct

    The data structure in which all data and code (and anything else) reside
    is called a bstruct (which stands for Babel-struct... I'm very creative).
    It is important to note that the Babel interpreter does not maintain any
    state which is not stored in a bstruct. This means that a bstruct at
    all times contains a complete image of the running program. This makes
    it trivial to load, save and restore Babel programs, even while they
    are mid-stream.

    (NB: "at all times" means whenever an operator has finished executing)

    A bstruct consists of one or more of the following data structures, 
    connected together:

        - leaf-array    : stores values
        - interior-array: stores pointers
        - hash-reference

    A bstruct may consist of:

        - a single leaf-array OR
        - an interior-array that may (recursively) point at one or more 
          interior-arrays, leaf-arrays and/or hash-references

    A bstruct is (intentionally) defined in such a way that it may contain
    any sort of data. There is nothing specific to Babel about a bstruct. For
    example, a large bitmap can be stored as a leaf-array by simply prepending
    it with the appropriate s-field in memory.

----- s-field

    To tell apart the three types of array, each array has an S-FIELD.
    The s-field is a single mword at position 0 in the allocated array. That
    is, the array can be freed by passing a pointer to the s-field to the 
    free() function. This permits clean destruction of a bstruct at any time.

        X.s > 0             X is a leaf-array
        X.s = 0             X is a hash-reference
        X.s < 0             X is an interior-array

    Aside from telling the array type, the s-field also tells the array size.
    The size is encoded in bytes so you have to divide by MWORD_SIZE to get
    the size in mwords.

        X.s > 0             X.size = X.s / MWORD_SIZE
        X.s = 0             X.size = 1 + HASH_SIZE
        X.s < 0             X.size = -1 * (X.s / MWORD_SIZE)

    The size of every array in a bstruct is an even multiple of MWORD_SIZE.

    The least-significant bit of the s-field is used during traversal of a
    bstruct, see below.

----- Entries

    All other mwords in an array other than the s-field are called entries.
    The zeroth entry is located at array index 1, immediately following the
    s-field.

----- Leaf-array

    A leaf-array contains one or more values stored in an array of mwords. The
    contents of a leaf-array do not have to be accessed in mword-aligned 
    fashion. For example, it is possible to access a particular byte in a 
    leaf-array.

    The defining feature of a leaf-array is that it cannot contain pointers to
    any other arrays.

    Array-8

    A leaf-array may also be stored as an "array-8". Array-8 is just a 
    convention for padding the last mword of a leaf array with a special 
    mword that indicates the byte length of the array. Babel strings are 
    stored as array-8 in native form, see "Strings" section below.
 
----- Interior-array

    An interior-array contains one or more pointers, each mword-sized. 

    The defining feature of an interior-array is that every mword in an 
    interior-array must contain a pointer to the zeroth entry of an array.

    A pointer in an interior-array may point at any other kind of array.

    Every pointer in an interior-array must contain a valid pointer to an 
    array.

----- Hash-reference

    A hash-reference is a single hash value stored in memory suitable for 
    fast lookup in the sym_table (symbol table).

    Hash-references have two uses:

        - By-name lookup of data
        - By-name eval
        - Creating "soft-links" that can emborder data-structures

    By-name lookup of data is performed by using the hash value to probe the
    sym_table. The result will be pushed on the stack.

    If you want to emborder a given data-structure so that the deep operators 
    of Babel do not continue traversing into other data-structures that are 
    pointed to by the given data-structure, you can use a hash-reference. 
    The built-in operators will stop traversing once they reach a hash-
    reference.

----- Traversing a bstruct

    A bstruct is a graph, not a tree. Hence, it may contain cycles. Traversal
    requires that each array be marked as it is visited. The least significant 
    bit of the s-field is used for this. The bstruct is actually traversed
    twice, once to set the LSB of each s-field in the bstruct and once to 
    clear it again.

----- Lists

    As a convention, the zeroth entry of an interior-array is also termed the 
    'car' field and the first entry is also termed the 'cdr' field. This 
    permits the construction of bstructs formally identical to lists in Lisp.

    Babel borrows the 'cons' 'car' 'cdr' etc. terminology from Lisp for 
    this purpose. "A list" always means the portion of a bstruct that conforms
    to this convention.

    nil behaves slightly differently in Babel than it does in Lisp. Since 
    Babel does not have a notion of an atomic value, nil cannot be an atom and
    never acts like one. Its primary use in Babel is to mark the end of a 
    list. It also serves some special functions in control-flow behavior.

----- Hashes

    Hashing is performed with the pearson16() which is a modification of 
    Pearson's 8-bit permutation hash to generate 16-byte (128-bit) hash
    values.

    Babel implements extendible hashing (Fagin, Nievergelt, Pippenger, 
    Strong, 1979) which means the hash table never needs to be re-hashed when
    items are inserted or deleted.

----- Namespaces

    Namespaces in Babel are hierarchical. A namespace is "just a label" by
    which to refer to something, it is not a "container", "object" or 
    "package". Everything lives in one namespace, so you cannot have a
    variable with the same name as a function, etc.

    The sym_table is just a namespace but the operators for using a
    namespace can be used by the user to maintain user namespaces. The key
    is to separate the idea of namespace-as-data-structure and *the* Babel
    namespace. The former will be referred to as simply "namespace" and the
    latter will be referred to as the sym_table.

    Babel maintains two pieces of state in addition to the sym_table. The
    pwd operator permits code to determine its current location within the
    sym_table. This is particularly useful for path-relative code that can 
    be loaded into any portion of the sym_table.

    The /babel/path namespace maintains a list of paths similar to Perl's
    @EXPORT variable. You can manipulate this variable using any of the 
    applicable Babel operators.

----- Babel Virtual Machine (bvm)

    A bvm is a bstruct with a particular structure to it. A bvm is a list 
    consisting of the following fields:

        (hidden code data stack rstack jmp_table sym_table nada)

    Once a bvm has begun executing, the pointer to this list is called the 
    internal_global_VM.

    The hidden field points to a bstruct containing information which is not
    visible to the currently executing bvm.

    The code field points to the currently executing entry.

    The data field points to data.
    
    The stack field points to "the" stack.

    The rstack field points to the managed stack or "return stack". This name
    is borrowed from Forth, h/t to Chuck Moore.

    The jmp_table field points to the jump table.

    The sym_table field points to the symbol table.

    car(nada) = 0
    cdr(nada) = nil

----- BVM Code

    Code is a list. Each element of the list is accessed in order. 

    When the next element of code_list is: 

        - A leaf-array, it is treated as an opcode and a lookup is performed
          in jmp_table

        - A hash-reference, it is looked up in the sym_table and control is
          transferred there, in a manner equivalent to eval.

        - An interior-array and its car is:

            - Not a hash-reference, it is pushed on the stack

            - A hash-reference, it is looked up in the sym_table and the result
              is pushed on the stack

----- BVM Stack

    The stack is where all operations are performed in Babel. The Babel 
    interpreter is a stack machine. Each operator operates on the stack and
    returns its results on the stack. There are no registers in Babel. No 
    internal state is maintained by the interpreter in C variables.

    The stack is itself a list, however, it includes some additional 
    information for memory-management. In order to conver the stack to a list, 
    use the stk2ls operator and use the ls2stk operator for vice-versa.

----- Invoking a BVM

    BVMs can be invoked in a nested manner, that is, a BVM may construct 
    another BVM and then invoke that BVM, transferring control to it until it
    exits. In fact, every Babel program executes inside of an invisible "root"
    BVM that is compiled into babel.exe. 

    This BVM contains code for the debugger and other basic commandline and 
    house-keeping functions.

----- Hidden section

    The hidden section contains limits and controls that restrict what the 
    BVM can do. For example, if you are launching a BVM fetched from the web
    you should disable operators that can write to disk, limit the memory 
    that it can allocate, taint data fetched locally (to prevent privacy 
    breaches), disable system call operators, disable nested virtual machines
    (to prevent stack-overflow attacks) and disable operator extension.

----- Operators

    The "active" component of Babel code consists of any of a number of 
    operators. There are two types of operators: built-in and extended. Each 
    operator is invoked through the jmp_table.

    - Built-in operators

        Built-in operators have a fixed numerical value below 0x1000. 

    - Extended operators

        The encoding for an extended operator has a value greater than 0x1000 
        but it is not fixed - an extended operator will be installed in the 
        "next available" jmp_table entry when it is installed. Babel code 
        should never attempt to directly rely on the encoded value of an 
        operator.

        An extended operator can be given an encoding with the newop operator.

        Extended operators can also be invoked by hash-reference. If the next
        entry in the code_list is a hash-reference, a lookup will be performed
        in the sym_table and the linked code will be invoked. Naturally, this
        is a lower-performance alternative.

----- Memory management

    Babel uses a combination of automatic and manual memory management.
    Memory associated with data-structures pointed to by the bvm_header are 
    automatically managed, according to specific rules. All other memory must
    be created and destroyed by the user through the newlf/newin and del
    operators.

----- Stack memory management

    - Built-ins

        Built-in operators can create results on the stack. The memory for
        these results is created automatically. When the values are consumed
        by another built-in operator, they are also automatically freed.

        For example,

            ([2] [3] add 

        ... creates the result {5} which is allocated automatically and put
        on the stack. When this result is then consumed by the next 
        instruction:

            [4] mul)

        ... the intermediate result {5} is freed and the new result {20} is 
        again automatically allocated put on the stack.

    - User operators

        User operators can provide a destructor function to Babel when they 
        are registered. This function will be called whenever the operator's
        results are consumed by another operator (built-in or otherwise).

        To signal consumption of a value (removal from the stack) to other 
        operators, call the zap() function.

----- Load memory management

    The load operator accepts a leaf-array containing an "offset relative" 
    bstruct as input and generates a "live" bstruct as output. In order to
    maintain the ability to destruct any portion of a bstruct at any time, the
    load operator is required to allocate every basic structure as it is 
    loaded from the leaf-array (it can't simply load in-place).

----- Namespace memory management

    Memory destruction within a namespace is hierarchical. This means that if 
    you create /foo/bar and then destroy /foo, /foo/bar will also be 
    destroyed. Note that simply removing a namespace does not affect memory
    allocation, it's when you use the del operator on a namespace.

    The book-keeping data in a namespace is always automatically memory-
    managed.

----- Hash memory management

    The book-keeping data in a hash is automatically memory-managed.

----- Semi-manual memory management

    The term "semi-manual" means manual allocation, automatic deletion of 
    memory. You can create a piece of semi-manually allocated memory by 
    providing a negative number to newin/newlf. To create a semi-manual memory 
    block of 10 mwords:

        ([-10] newlf

    ... now, when the memory is consumed, it will be de-allocated:

        zap)  -- Deallocates the 10-mword memory allocated above

----- P-numbers

    Babel has built-in support for arbitrary precision p-adic numbers, called 
    p-numbers for short. The p-operators (padd, psub, etc.) implement this
    functionality.

    To calculate the square-root of two to five words of precision:

        5 2 psqrt

----- File I/O

    Babel provides some "quick-and-dirty" I/O operators inspired by Perl's 
    slurp functionality.

    For more robust file functionality, Babel provides memory-mapped files.

----- Operand-checking

    Operand-checking is time-consuming and unnecessary for well-tested code.
    Most built-in operators are implemented with a core "unsafe" function and
    a wrapper operand-check function.

----- Jump table



----- Strings

    Babel has native support for UTF-8 encoded strings. Babel strings are not
    null-terminated. However, a Babel-string stored in array-8 form is always
    C-string safe because the alignment-word at the end of an array-8 always
    contains one or more null bytes. For example, in 32-bit Babel, the 
    alignment word is one of:

        0x00000000      byte-length % 4 = 0
        0xffffff00      byte-length % 4 = 1
        0xffff0000      byte-length % 4 = 2
        0xff000000      byte-length % 4 = 3

    You should always convert Babel strings to C form using the cr operator 
    but if a Babel string is mistakenly passed to a C function, it will not 
    cause an overrun.

    Babel handles strings in several different forms:

    - Native form. The string is UTF-8 encoded WITHOUT a null terminator in
    an array8 leaf-array

    - C-style. This is just a native string with a null terminator appended.

    - String-array. This is a leaf-array such that each entry in the array 
    contains the Unicode code-point of the encoded character. It is created
    from a native-form string via the str2ar operator.

    - String-list. This is a string-array on which the the ar2ls operator
    has been called.

----- Interpreter reset

    On invocation of the local babel binary from the command-line or by a
    system exec call, Babel begins a set of steps which are called Babel
    reset.

