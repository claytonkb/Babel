// hash.c
//

#include "babel.h"
#include "hash.h"
#include "list.h"
#include "except.h"
#include "array.h"
#include "stack.h"
#include "pearson16.h"
#include "bvm.h"
#include "bvm_opcodes.h"
#include "bstruct.h"
#include "tlist.h"
#include "string.h"


//
//
mword *new_hash_table(void){ // new_hash_table#

//    return _new_tlist(  _hash8(C2B("/babel/tag/hash_table")), 
//                        _consls( _consls(nil, nil), nil ) );

    return _new_tlist(  _hash8(C2B("/babel/tag/hash_table")), 
                        consa( consa(nil, nil), nil ) );

}


//
//
mword *new_hash_table_entry(mword *hash, mword *key, mword *payload){  // new_hash_table_entry#

    if(is_nil(hash)){
        hash = _hash8(key); //FIXME: detect key == nil
    }
    else{
        hash = _cp(hash);
    }

    if(!is_nil(key)){
        key = _cp(key);
    }

    return _new_tlist(
        _hash8(C2B("/babel/tag/hash_table_entry")), 
        consa( hash,
            consa( key,
                consa( payload, nil )))
    );

}


// entry is generated by _new_hash_table_entry, e.g:
//  _insha(my_hash_table, my_hash, my_key, _new_hash_table_entry(my_hash, my_key, my_data));
//
void _insha(mword *hash_table, mword *hash, mword *key, mword *entry){ // _insha#

    if(is_nil(hash)){
        hash = _hash8(key); //FIXME: detect key == nil
    }
    else{
        hash = _cp(hash);
    }

    if(!is_nil(key)){
        key = _cp(key);
    }

    rinsha((mword*)tcar(hash_table), hash, key, entry, 0);

}


//
//
static void rinsha(mword *hash_table, mword *hash, mword *key, mword *entry, mword level){ // rinsha#

    mword cons_side   = _cxr1(hash,level);
    mword *next_level;
    mword *payload;

    if(cons_side){
        next_level = scdr(hash_table);
    }
    else{
        next_level = scar(hash_table);
    }

    // 1. cons_side = nil
    //      insert
    // 2. cons_side is inte AND size = 2
    //      recurse
    // 3. cons_side is inte AND size = HASH_ENTRY_SIZE
    //      split and insert

    if(is_nil(next_level)){
        (mword*)c(hash_table,cons_side) = entry;
    }
    else if(is_conslike(next_level)){
        rinsha((mword*)c(hash_table,cons_side), hash, key, entry, level+1);
    }
    else if(is_tlist(next_level)){ //XXX: We are ASSUMING it's a hash_table_entry...

        if(tagcmp(car(next_level),hash) == 0){ //already exists...

            payload = (mword*)cdr(cdr(next_level));
            c(payload,0) = car(cdr(cdr(entry)));

        }
        else{

            if( _cxr1( (mword*)tcar(next_level), level+1 ) ){
                (mword*)c(hash_table,cons_side) = consa( nil, next_level );
            }
            else{
                (mword*)c(hash_table,cons_side) = consa( next_level, nil );
            }

            rinsha((mword*)c(hash_table,cons_side), hash, key, entry, level+1);

        }

    }
    else{
        _dump(next_level);
        die;
        enhance("Exception due to error inserting into hash");
    }

}


//
//
mword _exha(mword *hash_table, mword *hash){ // _exha#

    if(is_nil(hash_table)){
        return 0;
    }
    else{
        return rexha(hash_table, hash, 0);
    }

}


//
//
static mword rexha(mword *hash_table, mword *hash, mword level){ // rexha#

    mword *temp;
    mword cons_side   = _cxr1(hash,level);
    mword *next_level = (mword*)cxr(hash_table,cons_side);

    //FIXME: Check level == HASH_BIT_SIZE

    if(is_nil(next_level)){ //dead-end
        return 0;
    }
    else if(is_conslike(next_level)){
        rexha((mword*)c(hash_table,cons_side), hash, level+1);
    }
    else if(is_tlist(next_level)){ // XXX ASSUMES well-formed hash-entry
        return (tagcmp(car(next_level),hash) == 0);
    }

}


//
//
mword *_luha(mword *hash_table, mword *hash){ // _luha#

    mword *result;

    if(is_nil(hash_table)){
        return nil;
    }
    else{
        return rluha(hash_table, hash, 0);
    }

    return result;

}


//
//
static mword *rluha(mword *hash_table, mword *hash, mword level){ // rluha#

    mword *temp;
    mword cons_side   = _cxr1(hash,level);
    mword *next_level = (mword*)c(hash_table,cons_side);

    //FIXME: Check level == HASH_BIT_SIZE

    if(is_nil(next_level)){ //dead-end
        return nil;
    }
    else if(is_conslike(next_level)){
        return rluha((mword*)c(hash_table,cons_side), hash, level+1);
    }
    else if(is_tlist(next_level)){ // XXX ASSUMES well-formed hash-entry
        return (mword*)car(cdr(cdr(next_level)));
    }

}


// returns: 1 if an entry was removed, 0 otherwise
//
mword _rmha(mword *hash_table, mword *hash){ // _rmha#

    if(is_nil(hash_table)){
        return 0;
    }
    else{
        return rrmha(hash_table, hash, 0);
    }

}


//
//
static mword rrmha(mword *hash_table, mword *hash, mword level){ // rrmha#

    mword *temp;
    mword cons_side   = _cxr1(hash,level);
    mword *next_level = (mword*)cxr(hash_table,cons_side);

    //FIXME: Check level == HASH_BIT_SIZE

    //FIXME: Fully re-collapse the tree after removal of an entry...

    if(is_nil(next_level)){ //dead-end
        return 0;
    }
    else if(is_conslike(next_level)){
        if(rrmha((mword*)c(hash_table,cons_side), hash, level+1)){
            if(    is_nil( (mword*)c(next_level,  cons_side) ) 
                && is_nil( (mword*)c(next_level,1-cons_side) )){ //FIXME: performs a check on every level... redundant
                (mword*)c(hash_table,cons_side) = nil; //FIXME: De-allocation
            }            
            return 1;
        }
        return 0;
    }
    else if(is_tlist(next_level)){ // XXX ASSUMES well-formed hash-entry

        if(tagcmp(car(next_level),hash) == 0){ //match
            (mword*)c(hash_table,cons_side) = nil; //FIXME: De-allocation
            return 1;
        }
        else{
            return 0;
        }

    }

}

// Clayton Bauman 2011

