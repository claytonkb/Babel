// hash.c
//
//

#include "babel.h"
#include "hash.h"
#include "tptr.h"
#include "list.h"
#include "bstruct.h"
#include "pearson16.h"
#include "string.h"
#include "array.h"
#include "introspect.h"
#include "operator.h"
#include "trie.h"


// Returns a list of all entries in the hash
//
mword *_entha(bvm_cache *this_bvm, mword *hash_table){ // _entha#

    if(is_tptr(hash_table)){ 
        hash_table = get_tptr(hash_table);
    }

    if(is_nil(hash_table)){
        return nil;
    }
    else{
        return _rentha(this_bvm, hash_table, 0);
    }

}


//
//
mword *_rentha(bvm_cache *this_bvm, mword *hash_table, mword level){ // _rentha#

    //FIXME: Check for level > HASH_BIT_SIZE

    if(is_nil(hash_table)){ //dead-end

        return nil;
    }
    else if(is_conslike(hash_table)){

        mword *list0 = _rentha(this_bvm, (mword*)car(hash_table), level+1);
        mword *list1 = _rentha(this_bvm, (mword*)cdr(hash_table), level+1);

        if(is_nil(list0)){
            if(is_nil(list1)){
                return nil;
            }
            else{
                return list1;
            }
        }
        else{
            if(is_nil(list1)){
                return list0;
            }
            else{
                return _append_direct(this_bvm, list0, list1);
            }
        }

    }
    else if(is_tptr(hash_table)){
        return _cons(this_bvm, tptr_hard_detag(this_bvm, hash_table),nil);
    }
    else{
        _fatal("unexpected element in hash-table"); //FIXME: except, not fatal
    }

}


//
//
mword *hash_new_table(bvm_cache *this_bvm){ // hash_new_table#

    return tptr_new(this_bvm, HASH8(this_bvm, "/babel/tag/hash_table"), 
                        _cons(this_bvm, _cons(this_bvm, nil, nil), nil ));

}


//
//
mword *hash_new_entry(bvm_cache *this_bvm, mword *hash, mword *key, mword *payload){  // hash_new_entry#

    if(is_nil(hash)){
        hash = _hash8(this_bvm, key); //FIXME: detect key == nil
    }
    else{
        hash = _cp(this_bvm, hash);
    }

    if(!is_nil(key)){
        key = _cp(this_bvm, key);
    }

    mword *temp = tptr_new(this_bvm, 
        HASH8(this_bvm, "/babel/tag/hash_table_entry"), 
        _cons(this_bvm,  hash,
            _cons(this_bvm,  key,
                _cons(this_bvm,  payload, nil )))
    );

    return temp;

}


// entry is generated by _hash_new_entry, e.g:
//  _insha(this_bvm, my_hash_table, my_hash, my_key, _hash_new_entry(my_hash, my_key, my_data));
//
void _insha(bvm_cache *this_bvm, mword *hash_table, mword *hash, mword *key, mword *entry){ // _insha#

    mword is_nil_key  = is_nil(key);
    mword is_nil_hash = is_nil(hash);

    if(is_nil_hash && is_nil_key){
        return; // Both hash and key are nil; fnord
    }
    else if(is_nil_hash && !is_nil_key){
        hash = _hash8(this_bvm, key);
        key  = _cp(this_bvm, key);
    }
    else if(!is_nil_hash && is_nil_key){
        hash = _cp(this_bvm, hash);
        key  = _val(this_bvm, 0); //same as _cp of empty_string
    }
    else{ //if(!is_nil_hash && !is_nil_key)
        hash = _cp(this_bvm, hash);
        key  = _cp(this_bvm, key);
    }

    _rinsha(this_bvm, (mword*)get_tptr(hash_table), hash, key, entry, 0);

//    if(is_nil(key)){
//        return;
//    }
//
//    if(is_nil(hash)){
//        hash = _hash8(this_bvm, key);
//    }
//    else{
//        hash = _cp(this_bvm, hash);
//    }
//
//    if(!is_nil(key)){
//        key = _cp(this_bvm, key);
//    }
//
//    _rinsha(this_bvm, (mword*)get_tptr(hash_table), hash, key, entry, 0); //XXX: was using tcar
//

}


//
//
void _rinsha(bvm_cache *this_bvm, mword *hash_table, mword *hash, mword *key, mword *entry, mword level){ // _rinsha#

    mword cons_side   = _cxr1(this_bvm, hash,level);
    mword *next_level;
    mword *payload;

    if(cons_side){
        next_level = scdr(hash_table);
    }
    else{
        next_level = scar(hash_table);
    }

    // 1. cons_side = nil
    //      insert
    // 2. cons_side is inte AND size = 2
    //      recurse
    // 3. cons_side is inte AND size = HASH_ENTRY_SIZE
    //      split and insert

    if(is_nil(next_level)){
        lci(hash_table,cons_side) = entry;
    }
    else if(is_conslike(next_level)){
        _rinsha(this_bvm, rci(hash_table,cons_side), hash, key, entry, level+1);
    }
    else if(is_tptr(next_level)){ //XXX: We are ASSUMING it's a hash_table_entry...

        if(tageq(car(next_level),hash,TAG_SIZE)){ //already exists...

            payload = (mword*)cdr(cdr(next_level));
            lci(payload,0) = car(cdr(cdr(entry)));

        }
        else{

            if( _cxr1(this_bvm,  (mword*)car(next_level), level+1 ) ){ //XXX: was using tcar
                lci(hash_table,cons_side) = _cons(this_bvm,  nil, next_level );
            }
            else{
                lci(hash_table,cons_side) = _cons(this_bvm,  next_level, nil );
            }

            _rinsha(this_bvm, lci(hash_table,cons_side), hash, key, entry, level+1);

        }

    }
    else{
        _dump(next_level);
        _die;
    }

}


//
//
mword _exha(bvm_cache *this_bvm, mword *hash_table, mword *hash){ // _exha#

    if(is_nil(hash_table)){
        return 0;
    }
    else{
        return _rexha(this_bvm, hash_table, hash, 0);
    }

}


//
//
mword _rexha(bvm_cache *this_bvm, mword *hash_table, mword *hash, mword level){ // _rexha#

    mword cons_side   = _cxr1(this_bvm, hash,level);
    mword *next_level = rci(hash_table,cons_side);

    //FIXME: Check level > HASH_BIT_SIZE

    if(is_nil(next_level)){ //dead-end
        return 0;
    }
    else if(is_conslike(next_level)){
        return _rexha(this_bvm, lci(hash_table,cons_side), hash, level+1);
    }
    else if(is_tptr(next_level)){ // XXX ASSUMES well-formed hash-entry
        return (tageq(car(next_level),hash,TAG_SIZE));
    }

    return 0; // silence compiler warning

}


//
//
mword *_luha(bvm_cache *this_bvm, mword *hash_table, mword *hash){ // _luha#

    mword *result;

    if(is_nil(hash_table)){
        return nil;
    }
    else{
        return _rluha(this_bvm, hash_table, hash, 0);
    }

    return result;

}


//
//
mword *_rluha(bvm_cache *this_bvm, mword *hash_table, mword *hash, mword level){ // _rluha#

    mword cons_side   = _cxr1(this_bvm, hash,level);
    mword *next_level = rci(hash_table,cons_side);

    //FIXME: Check level == HASH_BIT_SIZE
    //FIXME: do full tag check on the entry before returning it
    //FIXME: don't crash when failing to find a hash entry

    if(is_nil(next_level)){ //dead-end
        return nil;
    }
    else if(is_conslike(next_level)){
        return _rluha(this_bvm, rci(hash_table,cons_side), hash, level+1);
    }
    else if(is_tptr(next_level)){ // XXX ASSUMES well-formed hash-entry
        //_dump(detag(this_bvm, next_level));
        //return (mword*)car(cdr(cdr(next_level)));
        //return _ith(this_bvm, detag(this_bvm, next_level), 2);
        //return HASH_ENTRY_PAY(this_bvm, next_level);
        return next_level;
    }

    return nil; // silence compiler warning

}


// returns: 1 if an entry was removed, 0 otherwise
//
mword _rmha(bvm_cache *this_bvm, mword *hash_table, mword *hash){ // _rmha#

    if(is_nil(hash_table)){
        return 0;
    }
    else{
        return _rrmha(this_bvm, hash_table, hash, 0);
    }

}


//
//
mword _rrmha(bvm_cache *this_bvm, mword *hash_table, mword *hash, mword level){ // _rrmha#

    mword cons_side   = _cxr1(this_bvm, hash,level);
    mword *next_level = (mword*)cxr(this_bvm,hash_table,cons_side);

    //FIXME: Check level == HASH_BIT_SIZE

    //FIXME: Fully re-collapse the tree after removal of an entry...

    if(is_nil(next_level)){ //dead-end
        return 0;
    }
    else if(is_conslike(next_level)){
        if(_rrmha(this_bvm, rci(hash_table,cons_side), hash, level+1)){
            if(    is_nil( rci(next_level,  cons_side) ) 
                && is_nil( rci(next_level,1-cons_side) )){ //FIXME: performs a check on every level... redundant
                lci(hash_table,cons_side) = nil; //FIXME: De-allocation
            }            
            return 1;
        }
        return 0;
    }
    else if(is_tptr(next_level)){ // XXX ASSUMES well-formed hash-entry

        if(tageq(car(next_level),hash,TAG_SIZE)){ //match
            lci(hash_table,cons_side) = nil; //FIXME: De-allocation
            return 1;
        }
        else{
            return 0;
        }

    }

    return 0; // silence compiler warning

}


/*****************************************************************************
 *                                                                           *
 *                              HASH OPERATORS                               *
 *                                                                           *
 ****************************************************************************/

// 0 : array8 containing string to be hashed
#define HASH_8_OPERATIONS \
    result0 = _hash8(this_bvm, oi0.data); 

OPERATORA_R1_W1_D(hash_8d, HASH_8_OPERATIONS, nil, OI_MASK_LEAF, 0, 0)


// 0 : array containing mwords to be hashed
#define HASH_M_OPERATIONS \
    result0 = _hash(this_bvm, oi0.data); 

OPERATORA_R1_W1_D(hash_md, HASH_M_OPERATIONS, nil, OI_MASK_LEAF, 0, 0)


#define ENTSHA_D_OPERATIONS \
    result0 = _entha(this_bvm, oi0.data); 

OPERATORA_R1_W1_D(entsha_d, ENTSHA_D_OPERATIONS, nil, OI_MASK_TPTR|OI_MASK_INTE, 0, 0)


// :
#define NEWHA_OPERATIONS \
    result0 = trie_new(this_bvm); 

OPERATORA_R0_W1(newha, NEWHA_OPERATIONS)


// 0 : leaf array containing hashed key
// 1 : pointer to hash table
#define LUHA_OPERATIONS \
    result0 = trie_lookup_hash(this_bvm, oi1.data, oi0.data, nil);

OPERATORA_R2_W1_D(luha_d, LUHA_OPERATIONS, 
        nil, OI_MASK_LEAF|OI_MASK_TPTR, 0, 0,
        nil, OI_MASK_INTE|OI_MASK_TPTR, 0, 0)


// 0 : leaf array containing hashed key
// 1 : pointer to hash table
#define RMHA_OPERATIONS \
    result0 = _val(this_bvm, trie_remove(this_bvm, oi1.data, oi0.data, nil));

//mword trie_remove(bvm_cache *this_bvm, mword *trie, mword *key, mword *secondary_key){ // trie_remove#

OPERATORA_R2_W1_D(rmha_d, RMHA_OPERATIONS, 
        nil, OI_MASK_LEAF|OI_MASK_TPTR, 0, 0,
        nil, OI_MASK_INTE|OI_MASK_TPTR, 0, 0)


#define INSHA_D_OPERATIONS      \
    trie_insert(this_bvm,       \
            oi2.data,           \
            oi1.data,           \
            nil,                \
            oi0.data);

OPERATORA_R3_W0_D(insha_d, 
        INSHA_D_OPERATIONS, 
        0, OI_MASK_ANY, 0, 0,
        0, OI_MASK_LEAF|OI_MASK_TPTR, 0, 0,
        0, OI_MASK_ANY, 0, 0)


#define INSKHA_D_OPERATIONS                \
    trie_insert(this_bvm,                  \
            oi2.data,                      \
            _hash8( this_bvm, oi1.data ),  \
            oi1.data,                      \
            oi0.data);

OPERATORA_R3_W0_D(inskha_d, 
        INSKHA_D_OPERATIONS, 
        0, OI_MASK_ANY, 0, 0,
        0, OI_MASK_LEAF|OI_MASK_TPTR, 0, 0,
        0, OI_MASK_ANY, 0, 0)


#define EXHA_D_OPERATIONS \
    result0 = _val(this_bvm, trie_exists(this_bvm, oi1.data, oi0.data, nil));

OPERATORA_R2_W1_D(exha_d, EXHA_D_OPERATIONS, 
        nil, OI_MASK_ANY, 0, 0,
        nil, OI_MASK_ANY, 0, 0)


// Clayton Bauman 2014

