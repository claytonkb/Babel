----- Compiling Babel

My scripts are set up using Cygwin and I'm currently compiling for a Win32 target
using the tcc C compiler (I have the compiler in the repo because I eventually plan
to link to it). Babel might actually compile to *nix but I haven't tried it yet.

To compile Babel, you'll need to make a 'bin' directory in the project directory,
otherwise the make.pl script will crash. Once you've created the 'bin' directory,
just run:

perl make.pl

This will build babel.exe in the bin directory. You are now ready to run Babel.

----- Compiling and running your own Babel code

There are two basic ways to compile and run Babel code. The first (preferred)
way is to use the 'babel' Perl script:

perl babel my_proto_babel_program.pb

This wrapper script handles the invocation of the proto_babel.pl script and
invokes babel.exe for you automatically. The second way is to do these
steps manually. You'll need to do this whenever the wrapper script blows up
for reasons I haven't yet determined (I suspect memory leaks or freeing of 
dangling pointers is causing this).

perl proto_babel.pl my_proto_babel_program.pb pb/header.pb pb/opcodes.pb

Then:

bin/babel.exe my_proto_babel_program.pb.bbl

----- Installing Graphviz on windows

If you want to use the 'bbl2gv' (Babel-to-Graphviz) operator to provide visualization 
of the Babel data-structure, you will need to install Graphviz dot (on Windows; it's
installed by default in most Linux distros). In order to view the output, you will 
need to redirect it to a file:

perl babel eg/bbl2gv.pb > eg/bbl2gv.dot

Download the Graphviz software for your version of Windows and install it. Then, run
the following command:

dot -Tsvg eg/bbl2gv.dot > eg/bbl2gv.svg

Now, open the eg/bbl2gv.svg file in any web browser (Chrome and Firefox both work well
for me).

----- Babel Overview

Babel is an interpreter. For now, I am using a Perl script (proto_babel.pl)
as the front-end assembler/compiler for the interpreter. The full front-end 
is not yet developed. It will be called "Babel Program Description Language" 
(BPDL pronounced "bipedal").

Babel v0.10 is the very first baby release of the Babel interpreter. It has
support for basic C integer arithmetic operations, flow-control, I/O, 
branching and a selection of Babel-specific operators.

Babel is extremely raw. There is very little operand checking, exceptions
are always fatal IF an exception check is even performed. There's already
some bad 32-bit-only code. Basically, "don't make mistakes unless you want
things to blow up" is the rule for writing Babel code at this point in 
time.

The proto_babel.pl script is the front-end that does the dirty work of
generating native Babel programs. Here's an overview.

A .pb file consists of a series of labeled sections. Each section is
independent from the point-of-view of the script. You can define as many
sections as you like and the script won't care. The one required section 
is main. From there, the script just grabs each section as-needed while
building the .bbl file. You can include multiple .pb files on the command-
line and they will all be flattened into a single file by the script.

In my example .pb files, I use the convention of a code section to store
my program. This is where the interpreter begins executing. You can define
additional sections as desired but you have to observe the rules of 
how sections behave when using them in your code.

The code section is a "list" in the Lisp sense. However, unlike Lisp,
proto-Babel does not have the parentheses construct (S-expressions)
that permit you to make a list, such as: (apples oranges bananas) or
Python-style (apples, oranges, bananas)

Instead, you have to make lists through inclusion:

[apples [oranges [bananas]]]

If you wrote:

[apples oranges bananas]

... the script will not complain because this is valid but it just
doesn't do what you mean, at least, not for code. All code must be 
in the nested [apples [oranges [bananas]]] layout.

A convention I use to make this less tiresome is to put a left-edge
of open-brackets [ beside my code and orient the code vertically.

code:
    [ [{"Hello, world}]
    [ b2c
    [ cprints
    nil ]]]

At the bottom, I place the "nil ]]]" and just keep typing ] until my text
editor shows a match with the first [ under code:

The curly-braces {} define an array of values - also called a "leaf array":

{0 1 2 3}

A value is either a number or text and nothing else:

{"apples bananas oranges" 0 "ET phone home"}

{ {0} } <-- illegal! Leaf arrays cannot nest

Numbers and text constants cannot be placed outside of curly-braces in 
proto-Babel.

The square-brackets define an array of pointers - also called an "interior 
array". A pointer can be to an array of values or to another array of 
pointers and nothing else.

[0] <--- illegal!

[{0}] <--- this is what you really mean

[[apples][oranges][bananas]] <--- nested interior arrays

Labels allow the definition of sections. A section contains either a leaf-
array or an interior-array and nothing else:

my_number: 
    0x10 <--- illegal!

This is what you really mean:

my_number:
    {0x10}

my_interior_array:
    [ {0x10} {0x20} [{0x30}] ]

You don't have to indent sections but I do it by convention.

A section-name can be used as a label:

the_number_two:
    {2}

code:
    [ [the_number_two]
    [ [{3}]
    [ cuadd
    nil]]]

Generally, you can think of the use of a label as a "text-substitution"
but it's really a pointer. Hence, labels cannot be used inside leaf arrays:

{the_number_two} <--- illegal!

This is what you really mean:

{*the_number_two}

The addition of an asterisk before the section-name converts the label to
an "in-place expansion". Think of this as "remove the outermost brackets
and insert here."

{1 *the_number_two 3 4 5}

and

{1 2 3 4 5}

... are literally equivalent and generate exactly the same bytes.

You can use in-place expansion for interior arrays, as well - the main:
section in any of the example .pb files shows this.

Every Babel operator is just a number defined in the opcodes.pb file. To
successfully compile code with the proto_babel.pl script, you will need
to pass in the opcodes.pb file on the command-line along with the .pb file
you are trying to assemble.

You can example the .pb.lst file that is generated to see the literal 
layout of the bytes in the program.

Line comments are specified by double-dash

-- This is a comment

##### Built-in functions, naming conventions and mnemonics

Babel v0.10 supports a subset of the final built-in functions that are
planned for Babel 1.0.

abbr    meaning
-----------------
ar      array
ls      list

in      interior
lf      leaf

pt      pointer
va      value

str     string

stk     stack

A 'c' as the first letter of the operand name usually means "C-language".
'cu' means "C unsigned" and 'ci' means "C integer (signed)" and 'ca' means
"C arithmetic"

So, for example:

cuadd       "C unsigned addition"
ciadd       "C integer addition"
cashl       "C arithmetic shift-left"

As for ordering of operands, I applied the following rule as consistently
as possible:

A B op   <===>   "A op B"

For example, consider subtraction:

A B cusub    <===>   "A - B"

Or division,

A B cudiv   <===>   "A / B"

The directionality is consistently left-to-right. So, for example,
to use the w operator (write):

A B OFFSET w    <===>   "A write to B at OFFSET"

... or "A -> B" or "A flows into B" "from A to B"

test
