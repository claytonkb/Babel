If you are looking for an overview of Babel, see the "Overview" section
below.

----- Compiling Babel

My scripts are set up using Cygwin and I'm currently compiling for a Win32 
target using the tcc C compiler (I have the compiler in the repo because I 
eventually plan to link to it). Babel might actually compile to *nix but I 
haven't tried it yet. Eventually, Babel will be cross-compiled on both
Windows and *nix. To compile Babel, just run:

    perl make.pl

This will build babel.exe in the bin directory. You are now ready to run 
Babel.

    perl babel eg/hello_world.pb

----- Compiling and running your own Babel code

There are two basic ways to compile and run Babel code. The first 
(preferred) way is to use the 'babel' Perl script:

    perl babel my_proto_babel_program.pb

This wrapper script handles the invocation of the proto_babel.pl script 
and invokes babel.exe for you automatically. The second way is to do 
these steps manually. You'll need to do this whenever the wrapper script 
blows up, which can happen for a variety of reasons.

    perl proto_babel.pl my_proto_babel_program.pb pb/header.pb pb/opcodes.pb

Then:

    bin/babel.exe my_proto_babel_program.pb.bbl

----- Installing Graphviz on windows

If you want to use the dump (Babel-to-Graphviz) operator to provide 
visualization of the Babel data-structure, you will need to install 
Graphviz dot (on Windows; it's installed by default in any Linux 
distro I'm aware of). In order to view the output, you will need to 
redirect it to a file:

    perl babel eg/bbl2gv.pb > eg/bbl2gv.dot

Download the Graphviz software for your version of Windows and install it. 
Then, run the following command:

    dot -Tsvg eg/bbl2gv.dot > eg/bbl2gv.svg

Now, open the eg/bbl2gv.svg file in any web browser (Chrome and Firefox 
both work well for me).

Note that when you run the interpreter in debug mode, it automatically 
generates a "snapshot.dot" file, which is a visual snapshot of your entire 
Babel program.

----- Babel Overview

Babel is an interpreter. For now, I am using a Perl script (proto_babel.pl)
as the front-end assembler/compiler for the interpreter. The full front-end 
is not yet developed. It will be called "Babel Program Description Language" 
(BPDL pronounced "bipedal").

Babel v0.10 is the very first baby release of the Babel interpreter. It has
support for basic C integer arithmetic operations, flow-control, I/O, 
branching and a selection of Babel-specific operators.

Babel is extremely raw. There is very little operand checking, exceptions
are always fatal IF an exception check is even performed. Basically, 
don't make mistakes unless you want things to blow up.

The proto_babel.pl script is the front-end that does the dirty work of
generating native Babel programs.

----- Proto-Babel

A .pb file consists of a series of labeled sections. Each section is
independent from the point-of-view of the script. You can define as many
sections as you like and the script won't care. The one required section 
is main. From there, the script just grabs each section as-needed while
building the .bbl file. You can include multiple .pb files on the command-
line and they will all be flattened into a single file by the script.

Line comments are specified by double-dash

-- This is a comment

The curly-braces {} define an array of values - also called a "leaf array":

    {0 1 2 3}

A value is either a number or text and nothing else:

    {"apples bananas oranges"} {0} {"ET phone home"}

    { {0} } <-- illegal! Leaf arrays cannot nest

If you want to define a leaf-array containing a single number or single 
string, you can dispense with the curly-braces:

    18     <-- legal
    "foo"  <-- legal

The square-brackets define an array of pointers - also called an "interior 
array". A pointer can be to an array of values or to another array of 
pointers and nothing else.

    [0]

    [{0}]

    Nested interior arrays:

    [[apples][oranges][bananas]]

Labels allow the definition of sections. A section contains either a leaf-
array or an interior-array and nothing else:

    my_number: 0x10

    my_interior_array: [ 0x10 0x20 [30] "Hello!" ]

A section-name can be used as a label:

    the_number_two: 2

    main: ([the_number_two] [3] +)

Generally, you can think of the use of a label as a "text-substitution"
but it's really a pointer. Hence, labels cannot be used inside leaf arrays:

    {the_number_two} <--- illegal!

This is what you really mean:

    {*the_number_two}

The addition of an asterisk before the section-name converts the label to
an "in-place expansion". Think of this as "remove the outermost brackets
and insert here."

This:

    {1 *the_number_two 3 4 5}

and this:

    {1 2 3 4 5}

... are synonymous.

You can use in-place expansion for interior arrays, as well.

Lists are created with parentheses. A list in Babel means a linked-list in the
Lisp-sense. The following are equivalent:

    (1 2 3)
    [1 [2 [3 nil]]]

You can verify this by writing it both ways and looking into the .lst file 
after compiling with proto_babel.pl.

In Babel, data in the code-stream is differentiated from code by being 
"nested". For example, to add two numbers, the following are all equivalent:

    [42] [23] +             -- A
    (42) (23) +             -- B
    [42 nil] [23 nil] +     -- C

A, B and C all produce the same result when executed but note that A and B 
do not generate exactly the same byte-code but B and C do.

Often, the need arises in Babel to "wrap" an item in multiple parentheses. 
These parentheses are visually redundant (but necessary for semantic 
correctness). The quick-wrap syntax provides a less visually cluttered 
alternative:

    The following are all equivalent:

    (((1 2 3)))
    `((1 2 3))
    ``(1 2 3)

    For single items, you can use the back-tick directly:

    ````1
    ((((1))))

    `"Hello, world"
    ("Hello, world")

Every Babel operator is just a number defined in the pb/opcodes.pb file. To
successfully compile code with the proto_babel.pl script, you will need
to pass in the opcodes.pb file on the command-line along with the .pb file
you are trying to assemble.

You can use the .pb.lst file that is generated to see the literal layout 
of the bytes in the program.

----- Built-in functions, naming conventions and mnemonics

Babel v0.10 supports a subset of the final built-in functions that are
planned for Babel 1.0. See doc/babel_ref.txt for a list of Babel operators.

abbr    meaning
-----------------
ar      array
ls      list

in      interior
lf      leaf

pt      pointer
va      value

str     string

stk     stack

A 'c' as the first letter of the operand name usually means "C-language".
'cu' means "C unsigned" and 'ci' means "C integer (signed)" and 'ca' means
"C arithmetic"

So, for example:

cuadd       "C unsigned addition"
ciadd       "C integer addition"
cashl       "C arithmetic shift-left"

As for ordering of operands, I applied the following rule as consistently
as possible:

A B op   <===>   "A op B"

For example, consider subtraction:

A B -    <===>   "A - B"

Or division,

A B /    <===>   "A / B"

The flow of data is as consistently left-to-right as possible.

----- Documentation

doc/babel_phil.txt
    Documents the "Philosophy of Babel"

doc/babel_ref.txt
    Documents the built-in Babel operators

doc/babel_guts.txt
    Documents the internals of the Babel interpreter, as it is.

doc/babel_arch.txt
    Documents the final goal to which Babel is being developed

eg/*
    Contains many examples of Babel programs, somewhat disorganized at
    present but will improve over time.

