If you are looking for an overview of Babel, see the "Overview" section
below.

----- Compiling Babel

My scripts are set up using Cygwin and I'm currently compiling for a Win32 
target using the tcc C compiler (I have the compiler in the repo because I 
eventually plan to link to it). Babel might actually compile to *nix but I 
haven't tried it yet. Eventually, Babel will be cross-compiled on both
Windows and *nix.

To compile Babel, you'll need to make a 'bin' directory in the project 
directory, otherwise the make.pl script will crash. Once you've created 
the 'bin' directory, just run:

    perl make.pl

This will build babel.exe in the bin directory. You are now ready to run 
Babel.

----- Compiling and running your own Babel code

There are two basic ways to compile and run Babel code. The first 
(preferred) way is to use the 'babel' Perl script:

    perl babel my_proto_babel_program.pb

This wrapper script handles the invocation of the proto_babel.pl script 
and invokes babel.exe for you automatically. The second way is to do 
these steps manually. You'll need to do this whenever the wrapper script 
blows, which can happen for a variety of reasons.

    perl proto_babel.pl my_proto_babel_program.pb pb/header.pb pb/opcodes.pb

Then:

    bin/babel.exe my_proto_babel_program.pb.bbl

----- Installing Graphviz on windows

If you want to use the 'bbl2gv' (Babel-to-Graphviz) operator to provide 
visualization of the Babel data-structure, you will need to install 
Graphviz dot (on Windows; it's installed by default in any Linux 
distro I'm aware of). In order to view the output, you will need to 
redirect it to a file:

    perl babel eg/bbl2gv.pb > eg/bbl2gv.dot

Download the Graphviz software for your version of Windows and install it. 
Then, run the following command:

    dot -Tsvg eg/bbl2gv.dot > eg/bbl2gv.svg

Now, open the eg/bbl2gv.svg file in any web browser (Chrome and Firefox 
both work well for me).

Note that when you run the interpreter in debug mode, it automatically 
generates a "snapshot.dot" file, which is a visual snapshot of your entire 
Babel program.

----- Babel Overview

Babel is an interpreter. For now, I am using a Perl script (proto_babel.pl)
as the front-end assembler/compiler for the interpreter. The full front-end 
is not yet developed. It will be called "Babel Program Description Language" 
(BPDL pronounced "bipedal").

Babel v0.10 is the very first baby release of the Babel interpreter. It has
support for basic C integer arithmetic operations, flow-control, I/O, 
branching and a selection of Babel-specific operators.

Babel is extremely raw. There is very little operand checking, exceptions
are always fatal IF an exception check is even performed. Basically, 
don't make mistakes unless you want things to blow up.

The proto_babel.pl script is the front-end that does the dirty work of
generating native Babel programs.

----- Proto-Babel

A .pb file consists of a series of labeled sections. Each section is
independent from the point-of-view of the script. You can define as many
sections as you like and the script won't care. The one required section 
is main. From there, the script just grabs each section as-needed while
building the .bbl file. You can include multiple .pb files on the command-
line and they will all be flattened into a single file by the script.

In my example .pb files, I use the convention of a code section to store
my program. This is where the interpreter begins executing. You can define
additional sections as desired but you have to observe the rules of 
how sections behave when using them in your code.

The code section is a "list" in the Lisp sense. 

The curly-braces {} define an array of values - also called a "leaf array":

    {0 1 2 3}

A value is either a number or text and nothing else:

    {"apples bananas oranges" 0 "ET phone home"}

    { {0} } <-- illegal! Leaf arrays cannot nest

Numbers and text constants cannot be placed outside of curly-braces in 
proto-Babel.

The square-brackets define an array of pointers - also called an "interior 
array". A pointer can be to an array of values or to another array of 
pointers and nothing else.

    [0]

    [{0}]

    Nested interior arrays:

    [[apples][oranges][bananas]]

Labels allow the definition of sections. A section contains either a leaf-
array or an interior-array and nothing else:

    my_number: 0x10

my_interior_array: [ 0x10 0x20 [30] "Hello!" ]

You don't have to indent sections but I do it by convention.

A section-name can be used as a label:

    the_number_two: 2

    code: ([the_number_two] [3] cuadd)

Generally, you can think of the use of a label as a "text-substitution"
but it's really a pointer. Hence, labels cannot be used inside leaf arrays:

    {the_number_two} <--- illegal!

This is what you really mean:

    {*the_number_two}

The addition of an asterisk before the section-name converts the label to
an "in-place expansion". Think of this as "remove the outermost brackets
and insert here."

This:

    {1 *the_number_two 3 4 5}

and this:

    {1 2 3 4 5}

... are synonymous.

You can use in-place expansion for interior arrays, as well - the main:
section in any of the example .pb files shows this.

Every Babel operator is just a number defined in the pb/opcodes.pb file. To
successfully compile code with the proto_babel.pl script, you will need
to pass in the opcodes.pb file on the command-line along with the .pb file
you are trying to assemble.

You can use the .pb.lst file that is generated to see the literal layout 
of the bytes in the program.

Line comments are specified by double-dash

-- This is a comment

----- Built-in functions, naming conventions and mnemonics

Babel v0.10 supports a subset of the final built-in functions that are
planned for Babel 1.0. See doc/babel_ref.txt for a list of Babel operators.

abbr    meaning
-----------------
ar      array
ls      list

in      interior
lf      leaf

pt      pointer
va      value

str     string

stk     stack

A 'c' as the first letter of the operand name usually means "C-language".
'cu' means "C unsigned" and 'ci' means "C integer (signed)" and 'ca' means
"C arithmetic"

So, for example:

cuadd       "C unsigned addition"
ciadd       "C integer addition"
cashl       "C arithmetic shift-left"

As for ordering of operands, I applied the following rule as consistently
as possible:

A B op   <===>   "A op B"

For example, consider subtraction:

A B cusub    <===>   "A - B"

Or division,

A B cudiv   <===>   "A / B"

The directionality is consistently left-to-right. So, for example,
to use the w operator (write):

A B OFFSET w    <===>   "A write to B at OFFSET"

... or "A -> B" or "A flows into B" "from A to B"

----- Documentation

doc/babel_phil.txt
    Documents the "Philosophy of Babel"

doc/babel_ref.txt
    Documents the built-in Babel operators

doc/babel_guts.txt
    Documents the internals of the Babel interpreter, as it is.

doc/babel_arch.txt
    Documents the final goal to which Babel is being developed

eg/*
    Contains many examples of Babel programs, somewhat disorganized at
    present but will improve over time.

